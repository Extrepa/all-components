<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>An overhead projector - P5.js Sketch</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0a0a0a;
      color: #fff;
    }
    .container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    .header {
      padding: 1.5rem 2rem;
      background: #1a1a1a;
      border-bottom: 1px solid #333;
    }
    .header h1 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    .header p {
      color: #b0b0b0;
      font-size: 0.875rem;
    }
    .back-link {
      display: inline-block;
      margin-bottom: 1rem;
      color: #6366f1;
      text-decoration: none;
      font-size: 0.875rem;
    }
    .back-link:hover {
      text-decoration: underline;
    }
    #p5-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      background: #0a0a0a;
    }
    .info {
      padding: 1.5rem 2rem;
      background: #1a1a1a;
      border-top: 1px solid #333;
      font-size: 0.875rem;
    }
    .info-item {
      margin-bottom: 0.5rem;
      display: flex;
    }
    .info-label {
      width: 120px;
      color: #b0b0b0;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <a href="../index.html" class="back-link">‚Üê Back to Gallery</a>
      <h1>An overhead projector</h1>
      <p>P5.js Interactive Sketch</p>
    </div>
    <div id="p5-container"></div>
    <div class="info">
      <div class="info-item">
        <span class="info-label">Prompt:</span>
        <span>An overhead projector</span>
      </div>
      <div class="info-item">
        <span class="info-label">Model:</span>
        <span>threePro</span>
      </div>
      <div class="info-item">
        <span class="info-label">Generation Time:</span>
        <span>63.4s</span>
      </div>
    </div>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <script>
    const container = document.getElementById('p5-container');
    const sketchCode = "function setup() {\n  createCanvas(800, 600);\n  \n  // Create the transparency sheet buffer\n  transparencyLayer = createGraphics(300, 300);\n  transparencyLayer.colorMode(RGB);\n  transparencyLayer.clear();\n  \n  // Initial drawing on the transparency (a crude chart)\n  transparencyLayer.strokeWeight(3);\n  transparencyLayer.stroke(0, 0, 150, 200); // Blue marker\n  transparencyLayer.noFill();\n  transparencyLayer.beginShape();\n  transparencyLayer.vertex(50, 250);\n  transparencyLayer.vertex(100, 200);\n  transparencyLayer.vertex(150, 220);\n  transparencyLayer.vertex(200, 100);\n  transparencyLayer.vertex(250, 50);\n  transparencyLayer.endShape();\n  \n  transparencyLayer.stroke(200, 0, 0, 200); // Red underline\n  transparencyLayer.line(180, 110, 270, 60);\n  transparencyLayer.noStroke();\n  transparencyLayer.fill(0);\n  transparencyLayer.textSize(20);\n  transparencyLayer.text(\"Q4 PROJECTIONS\", 40, 50);\n\n  // Particle system for dust\n  for(let i=0; i<50; i++) {\n    dust.push({\n      x: random(200, 600),\n      y: random(0, 600),\n      size: random(1, 3),\n      speed: random(0.2, 1),\n      offset: random(1000)\n    });\n  }\n}\n\nlet isOn = true;\nlet transparencyLayer;\nlet dust = [];\nlet noiseOffset = 0;\n\n// Projector Geometry\nconst boxX = 400;\nconst boxY = 450;\nconst boxW = 400;\nconst boxH = 280;\nconst lensSize = 260;\n\nfunction draw() {\n  background(30); // Dark room\n  \n  // --- 1. THE WALL (Projection Surface) ---\n  noStroke();\n  fill(50);\n  rect(0, 0, width, 250); // Wall area\n  fill(20);\n  rect(0, 250, width, 350); // Desk/Floor area\n\n  // --- 2. PROJECTION LOGIC ---\n  if (isOn) {\n    push();\n    // Light Beam (Trapezoid)\n    noStroke();\n    // Use additive blending for light\n    blendMode(SCREEN);\n    \n    // The main trapezoid of light on the wall\n    fill(255, 253, 240, 150);\n    beginShape();\n    vertex(150, 20);  // Top Left Wall\n    vertex(650, 20);  // Top Right Wall\n    vertex(600, 230); // Bottom Right Wall\n    vertex(200, 230); // Bottom Left Wall\n    endShape(CLOSE);\n    \n    // The \"Cone\" in the air (subtle volumetric light)\n    fill(255, 255, 255, 15);\n    beginShape();\n    vertex(150, 20);\n    vertex(650, 20);\n    vertex(boxX + 120, boxY - 50); // Convergence near head\n    vertex(boxX - 120, boxY - 50);\n    endShape(CLOSE);\n\n    // Render the transparency content onto the wall\n    // Transform to fit the trapezoid\n    // Since applyMatrix is complex for 4-point distort, we'll map it simply to a rect \n    // positioned within the light area for the effect.\n    tint(255, 255, 255, 220); // Slightly transparent projection\n    // Flip Y visually because mirrors flip images, though usually OHP lenses correct this.\n    // We will just project it straight up.\n    image(transparencyLayer, 200, 30, 400, 200); \n    \n    // Add chromatic aberration / lens blur edges\n    tint(255, 0, 0, 50);\n    image(transparencyLayer, 202, 30, 402, 200);\n    tint(0, 0, 255, 50);\n    image(transparencyLayer, 198, 30, 398, 200);\n    \n    pop();\n\n    // Dust Motes in the light\n    drawDust();\n  }\n\n  // --- 3. THE PROJECTOR MACHINE ---\n  drawProjectorBody();\n\n  // --- 4. INTERACTION INSTRUCTIONS ---\n  drawUI();\n}\n\nfunction drawProjectorBody() {\n  rectMode(CENTER);\n  \n  // Shadow under the box\n  fill(0, 100);\n  rect(boxX + 10, boxY + 10, boxW, boxH, 20);\n\n  // Main Body Case\n  fill(180, 175, 160); // Retro Beige\n  stroke(100, 95, 85);\n  strokeWeight(2);\n  rect(boxX, boxY, boxW, boxH, 10);\n  \n  // Front Vent Grills\n  stroke(120, 115, 105);\n  for(let i = -150; i < 150; i+=15) {\n    line(boxX + i, boxY + 100, boxX + i, boxY + 120);\n  }\n  \n  // Power Switch Area\n  fill(150, 145, 135);\n  rect(boxX - 150, boxY + 110, 40, 30, 5);\n  \n  // Power Switch (Clickable)\n  if (isOn) {\n    fill(255, 100, 100); // Lit Red\n    boxShadow(boxX - 150, boxY + 110, 20, 15, 255, 50, 50, 20); // Glow\n  } else {\n    fill(100, 50, 50); // Dark Red\n  }\n  noStroke();\n  rect(boxX - 150, boxY + 110, 25, 15, 2);\n  \n  // --- THE GLASS STAGE ---\n  // Rim\n  stroke(140);\n  fill(200);\n  rect(boxX, boxY - 20, lensSize + 20, lensSize + 20, 5);\n  \n  // The Glass / Fresnel Lens\n  if (isOn) {\n    fill(240, 250, 255); // Bright white-blue\n  } else {\n    fill(100, 110, 120); // Dark glass\n  }\n  noStroke();\n  rect(boxX, boxY - 20, lensSize, lensSize);\n  \n  // Fresnel Rings Texture\n  noFill();\n  stroke(0, 20);\n  strokeWeight(1);\n  for (let r = 10; r < lensSize; r += 15) {\n    ellipse(boxX, boxY - 20, r, r);\n  }\n  \n  // --- TRANSPARENCY ON GLASS ---\n  // We draw the buffer directly onto the glass area\n  imageMode(CENTER);\n  image(transparencyLayer, boxX, boxY - 20, lensSize, lensSize);\n  \n  // --- ARM & HEAD ---\n  \n  // The Post (Right side)\n  fill(160, 155, 140);\n  stroke(80);\n  strokeWeight(2);\n  rect(boxX + 180, boxY - 100, 30, 300); // Vertical post\n  \n  // Focus Knob\n  fill(50);\n  rect(boxX + 180, boxY - 150, 35, 20);\n  \n  // The Arm extending over the glass\n  fill(170, 165, 150);\n  beginShape();\n  vertex(boxX + 165, boxY - 240);\n  vertex(boxX + 165, boxY - 200);\n  vertex(boxX, boxY - 180); // Connection to head\n  vertex(boxX, boxY - 220);\n  endShape(CLOSE);\n  \n  // The Head (Lens/Mirror Housing)\n  // Shadow of the head on the glass (if light is coming from below, shadow goes up, \n  // but usually ambient light casts a shadow down on the glass)\n  if (isOn) {\n    fill(0, 80);\n    noStroke();\n    ellipse(boxX, boxY - 20, 80, 80); // Silhouette of head blocking light\n  }\n  \n  // Physical Head Unit\n  stroke(80);\n  fill(150, 145, 130);\n  rect(boxX, boxY - 220, 100, 80, 5); // Main box\n  \n  // Lens opening pointing down\n  fill(20);\n  ellipse(boxX, boxY - 220, 60, 60);\n  \n  // Mirror angle indication\n  stroke(200, 200, 255, 100);\n  line(boxX - 30, boxY - 240, boxX + 30, boxY - 200);\n  \n  imageMode(CORNER); // Reset\n}\n\nfunction drawDust() {\n  noStroke();\n  fill(255, 200);\n  \n  noiseOffset += 0.01;\n  \n  for(let p of dust) {\n    // Update\n    p.y -= p.speed;\n    let n = noise(p.x * 0.01, p.y * 0.01, noiseOffset);\n    let wiggle = map(n, 0, 1, -1, 1);\n    \n    // Wrap around\n    if (p.y < 0) {\n      p.y = 250; // Reset to bottom of projection\n      p.x = random(200, 600);\n    }\n    \n    // Draw only if within light cone (rough approximation)\n    if (p.y < 230 && p.x > 150 && p.x < 650) {\n      ellipse(p.x + wiggle * 20, p.y, p.size);\n    }\n  }\n}\n\nfunction drawUI() {\n  fill(255);\n  noStroke();\n  textSize(14);\n  textAlign(LEFT, BOTTOM);\n  text(\"OVERHEAD PROJECTOR SIMULATOR\", 20, height - 40);\n  \n  fill(180);\n  textSize(12);\n  text(\"- Click Red Switch to Toggle Power\", 20, height - 25);\n  text(\"- Drag Mouse on Glass to Draw (Marker)\", 20, height - 10);\n  text(\"- Press 'C' to Clear Transparency\", 250, height - 10);\n  \n  // Marker Cursor Logic\n  if (mouseX > boxX - lensSize/2 && mouseX < boxX + lensSize/2 &&\n      mouseY > (boxY-20) - lensSize/2 && mouseY < (boxY-20) + lensSize/2) {\n    cursor(CROSS);\n  } else {\n    cursor(ARROW);\n  }\n}\n\n// Helper for simple glow\nfunction boxShadow(x, y, w, h, r, g, b, a) {\n  push();\n  blendMode(ADD);\n  noStroke();\n  for (let i = 0; i < 10; i++) {\n    fill(r, g, b, a - i*2);\n    rect(x, y, w + i*2, h + i*2, 5);\n  }\n  pop();\n}\n\nfunction mousePressed() {\n  // Toggle Switch Check\n  // Switch rect: boxX - 150, boxY + 110, 25, 15\n  let swX = boxX - 150;\n  let swY = boxY + 110;\n  if (mouseX > swX - 20 && mouseX < swX + 20 && mouseY > swY - 15 && mouseY < swY + 15) {\n    isOn = !isOn;\n    // Sound effect visual cue could go here\n  }\n}\n\nfunction mouseDragged() {\n  // Drawing on Transparency\n  // Map mouse coordinates relative to the glass stage to the buffer coordinates\n  let glassLeft = boxX - lensSize/2;\n  let glassTop = (boxY - 20) - lensSize/2;\n  \n  // Check bounds\n  if (mouseX > glassLeft && mouseX < glassLeft + lensSize &&\n      mouseY > glassTop && mouseY < glassTop + lensSize) {\n        \n    let bx = map(mouseX, glassLeft, glassLeft + lensSize, 0, transparencyLayer.width);\n    let by = map(mouseY, glassTop, glassTop + lensSize, 0, transparencyLayer.height);\n    let pbx = map(pmouseX, glassLeft, glassLeft + lensSize, 0, transparencyLayer.width);\n    let pby = map(pmouseY, glassTop, glassTop + lensSize, 0, transparencyLayer.height);\n    \n    transparencyLayer.stroke(0, 0, 0, 200); // Black Vis-a-Vis marker\n    transparencyLayer.strokeWeight(4);\n    transparencyLayer.line(pbx, pby, bx, by);\n  }\n}\n\nfunction keyPressed() {\n  if (key === 'c' || key === 'C') {\n    transparencyLayer.clear();\n  }\n}";
    
    const sketch = function(p) {
      function setup() {
  createCanvas(800, 600);
  
  // Create the transparency sheet buffer
  transparencyLayer = createGraphics(300, 300);
  transparencyLayer.colorMode(RGB);
  transparencyLayer.clear();
  
  // Initial drawing on the transparency (a crude chart)
  transparencyLayer.strokeWeight(3);
  transparencyLayer.stroke(0, 0, 150, 200); // Blue marker
  transparencyLayer.noFill();
  transparencyLayer.beginShape();
  transparencyLayer.vertex(50, 250);
  transparencyLayer.vertex(100, 200);
  transparencyLayer.vertex(150, 220);
  transparencyLayer.vertex(200, 100);
  transparencyLayer.vertex(250, 50);
  transparencyLayer.endShape();
  
  transparencyLayer.stroke(200, 0, 0, 200); // Red underline
  transparencyLayer.line(180, 110, 270, 60);
  transparencyLayer.noStroke();
  transparencyLayer.fill(0);
  transparencyLayer.textSize(20);
  transparencyLayer.text("Q4 PROJECTIONS", 40, 50);

  // Particle system for dust
  for(let i=0; i<50; i++) {
    dust.push({
      x: random(200, 600),
      y: random(0, 600),
      size: random(1, 3),
      speed: random(0.2, 1),
      offset: random(1000)
    });
  }
}

let isOn = true;
let transparencyLayer;
let dust = [];
let noiseOffset = 0;

// Projector Geometry
const boxX = 400;
const boxY = 450;
const boxW = 400;
const boxH = 280;
const lensSize = 260;

function draw() {
  background(30); // Dark room
  
  // --- 1. THE WALL (Projection Surface) ---
  noStroke();
  fill(50);
  rect(0, 0, width, 250); // Wall area
  fill(20);
  rect(0, 250, width, 350); // Desk/Floor area

  // --- 2. PROJECTION LOGIC ---
  if (isOn) {
    push();
    // Light Beam (Trapezoid)
    noStroke();
    // Use additive blending for light
    blendMode(SCREEN);
    
    // The main trapezoid of light on the wall
    fill(255, 253, 240, 150);
    beginShape();
    vertex(150, 20);  // Top Left Wall
    vertex(650, 20);  // Top Right Wall
    vertex(600, 230); // Bottom Right Wall
    vertex(200, 230); // Bottom Left Wall
    endShape(CLOSE);
    
    // The "Cone" in the air (subtle volumetric light)
    fill(255, 255, 255, 15);
    beginShape();
    vertex(150, 20);
    vertex(650, 20);
    vertex(boxX + 120, boxY - 50); // Convergence near head
    vertex(boxX - 120, boxY - 50);
    endShape(CLOSE);

    // Render the transparency content onto the wall
    // Transform to fit the trapezoid
    // Since applyMatrix is complex for 4-point distort, we'll map it simply to a rect 
    // positioned within the light area for the effect.
    tint(255, 255, 255, 220); // Slightly transparent projection
    // Flip Y visually because mirrors flip images, though usually OHP lenses correct this.
    // We will just project it straight up.
    image(transparencyLayer, 200, 30, 400, 200); 
    
    // Add chromatic aberration / lens blur edges
    tint(255, 0, 0, 50);
    image(transparencyLayer, 202, 30, 402, 200);
    tint(0, 0, 255, 50);
    image(transparencyLayer, 198, 30, 398, 200);
    
    pop();

    // Dust Motes in the light
    drawDust();
  }

  // --- 3. THE PROJECTOR MACHINE ---
  drawProjectorBody();

  // --- 4. INTERACTION INSTRUCTIONS ---
  drawUI();
}

function drawProjectorBody() {
  rectMode(CENTER);
  
  // Shadow under the box
  fill(0, 100);
  rect(boxX + 10, boxY + 10, boxW, boxH, 20);

  // Main Body Case
  fill(180, 175, 160); // Retro Beige
  stroke(100, 95, 85);
  strokeWeight(2);
  rect(boxX, boxY, boxW, boxH, 10);
  
  // Front Vent Grills
  stroke(120, 115, 105);
  for(let i = -150; i < 150; i+=15) {
    line(boxX + i, boxY + 100, boxX + i, boxY + 120);
  }
  
  // Power Switch Area
  fill(150, 145, 135);
  rect(boxX - 150, boxY + 110, 40, 30, 5);
  
  // Power Switch (Clickable)
  if (isOn) {
    fill(255, 100, 100); // Lit Red
    boxShadow(boxX - 150, boxY + 110, 20, 15, 255, 50, 50, 20); // Glow
  } else {
    fill(100, 50, 50); // Dark Red
  }
  noStroke();
  rect(boxX - 150, boxY + 110, 25, 15, 2);
  
  // --- THE GLASS STAGE ---
  // Rim
  stroke(140);
  fill(200);
  rect(boxX, boxY - 20, lensSize + 20, lensSize + 20, 5);
  
  // The Glass / Fresnel Lens
  if (isOn) {
    fill(240, 250, 255); // Bright white-blue
  } else {
    fill(100, 110, 120); // Dark glass
  }
  noStroke();
  rect(boxX, boxY - 20, lensSize, lensSize);
  
  // Fresnel Rings Texture
  noFill();
  stroke(0, 20);
  strokeWeight(1);
  for (let r = 10; r < lensSize; r += 15) {
    ellipse(boxX, boxY - 20, r, r);
  }
  
  // --- TRANSPARENCY ON GLASS ---
  // We draw the buffer directly onto the glass area
  imageMode(CENTER);
  image(transparencyLayer, boxX, boxY - 20, lensSize, lensSize);
  
  // --- ARM & HEAD ---
  
  // The Post (Right side)
  fill(160, 155, 140);
  stroke(80);
  strokeWeight(2);
  rect(boxX + 180, boxY - 100, 30, 300); // Vertical post
  
  // Focus Knob
  fill(50);
  rect(boxX + 180, boxY - 150, 35, 20);
  
  // The Arm extending over the glass
  fill(170, 165, 150);
  beginShape();
  vertex(boxX + 165, boxY - 240);
  vertex(boxX + 165, boxY - 200);
  vertex(boxX, boxY - 180); // Connection to head
  vertex(boxX, boxY - 220);
  endShape(CLOSE);
  
  // The Head (Lens/Mirror Housing)
  // Shadow of the head on the glass (if light is coming from below, shadow goes up, 
  // but usually ambient light casts a shadow down on the glass)
  if (isOn) {
    fill(0, 80);
    noStroke();
    ellipse(boxX, boxY - 20, 80, 80); // Silhouette of head blocking light
  }
  
  // Physical Head Unit
  stroke(80);
  fill(150, 145, 130);
  rect(boxX, boxY - 220, 100, 80, 5); // Main box
  
  // Lens opening pointing down
  fill(20);
  ellipse(boxX, boxY - 220, 60, 60);
  
  // Mirror angle indication
  stroke(200, 200, 255, 100);
  line(boxX - 30, boxY - 240, boxX + 30, boxY - 200);
  
  imageMode(CORNER); // Reset
}

function drawDust() {
  noStroke();
  fill(255, 200);
  
  noiseOffset += 0.01;
  
  for(let p of dust) {
    // Update
    p.y -= p.speed;
    let n = noise(p.x * 0.01, p.y * 0.01, noiseOffset);
    let wiggle = map(n, 0, 1, -1, 1);
    
    // Wrap around
    if (p.y < 0) {
      p.y = 250; // Reset to bottom of projection
      p.x = random(200, 600);
    }
    
    // Draw only if within light cone (rough approximation)
    if (p.y < 230 && p.x > 150 && p.x < 650) {
      ellipse(p.x + wiggle * 20, p.y, p.size);
    }
  }
}

function drawUI() {
  fill(255);
  noStroke();
  textSize(14);
  textAlign(LEFT, BOTTOM);
  text("OVERHEAD PROJECTOR SIMULATOR", 20, height - 40);
  
  fill(180);
  textSize(12);
  text("- Click Red Switch to Toggle Power", 20, height - 25);
  text("- Drag Mouse on Glass to Draw (Marker)", 20, height - 10);
  text("- Press 'C' to Clear Transparency", 250, height - 10);
  
  // Marker Cursor Logic
  if (mouseX > boxX - lensSize/2 && mouseX < boxX + lensSize/2 &&
      mouseY > (boxY-20) - lensSize/2 && mouseY < (boxY-20) + lensSize/2) {
    cursor(CROSS);
  } else {
    cursor(ARROW);
  }
}

// Helper for simple glow
function boxShadow(x, y, w, h, r, g, b, a) {
  push();
  blendMode(ADD);
  noStroke();
  for (let i = 0; i < 10; i++) {
    fill(r, g, b, a - i*2);
    rect(x, y, w + i*2, h + i*2, 5);
  }
  pop();
}

function mousePressed() {
  // Toggle Switch Check
  // Switch rect: boxX - 150, boxY + 110, 25, 15
  let swX = boxX - 150;
  let swY = boxY + 110;
  if (mouseX > swX - 20 && mouseX < swX + 20 && mouseY > swY - 15 && mouseY < swY + 15) {
    isOn = !isOn;
    // Sound effect visual cue could go here
  }
}

function mouseDragged() {
  // Drawing on Transparency
  // Map mouse coordinates relative to the glass stage to the buffer coordinates
  let glassLeft = boxX - lensSize/2;
  let glassTop = (boxY - 20) - lensSize/2;
  
  // Check bounds
  if (mouseX > glassLeft && mouseX < glassLeft + lensSize &&
      mouseY > glassTop && mouseY < glassTop + lensSize) {
        
    let bx = map(mouseX, glassLeft, glassLeft + lensSize, 0, transparencyLayer.width);
    let by = map(mouseY, glassTop, glassTop + lensSize, 0, transparencyLayer.height);
    let pbx = map(pmouseX, glassLeft, glassLeft + lensSize, 0, transparencyLayer.width);
    let pby = map(pmouseY, glassTop, glassTop + lensSize, 0, transparencyLayer.height);
    
    transparencyLayer.stroke(0, 0, 0, 200); // Black Vis-a-Vis marker
    transparencyLayer.strokeWeight(4);
    transparencyLayer.line(pbx, pby, bx, by);
  }
}

function keyPressed() {
  if (key === 'c' || key === 'C') {
    transparencyLayer.clear();
  }
}
    };
    
    new p5(sketch, container);
  </script>
</body>
</html>