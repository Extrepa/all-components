{
  "meta": {
    "totalProjects": 17,
    "glslCount": 5,
    "p5Count": 12,
    "extractedAt": "2026-01-09T23:46:00.999Z"
  },
  "projects": [
    {
      "projectId": "018e2ce7-7a56-48f7-a3ca-3afd7332a0c6",
      "outputId": "2e714824-87cf-4fa2-9c7d-2a8bf15fe7d3",
      "prompt": "inside of lava lamp",
      "mode": "glsl",
      "model": "threePro",
      "srcCode": "precision mediump float;\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n// Smooth minimum for metaball blending\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Rotate function\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Scene mapping (Signed Distance Function)\nfloat map(vec3 p) {\n    float d = 100.0;\n    \n    // Container bound (cylinder-ish push)\n    float container = length(p.xz) - 1.8;\n    d = max(-container, d); \n\n    // Generate blobs\n    for (int i = 0; i < 6; i++) {\n        float fi = float(i);\n        float t = u_time * (0.3 + fi * 0.05);\n        \n        // Complex vertical movement simulating convection\n        float y = 2.5 * sin(t + fi * 1.5) + sin(t * 2.3) * 0.5;\n        \n        // Horizontal wandering\n        float x = sin(t * 0.8 + fi) * (0.6 + 0.2 * sin(u_time * 0.1));\n        float z = cos(t * 0.7 + fi * 2.0) * (0.6 + 0.2 * cos(u_time * 0.15));\n        \n        // Pulsating size\n        float r = 0.4 + 0.15 * sin(u_time * 1.5 + fi);\n        \n        vec3 spherePos = vec3(x, y, z);\n        float sphereDist = length(p - spherePos) - r;\n        \n        // Blend blobs\n        d = smin(d, sphereDist, 0.8);\n    }\n    \n    return d;\n}\n\n// Calculate surface normal\nvec3 calcNormal(vec3 p) {\n    const float h = 0.001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * map(p + k.xyy * h) +\n                     k.yyx * map(p + k.yyx * h) +\n                     k.yxy * map(p + k.yxy * h) +\n                     k.xxx * map(p + k.xxx * h));\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n    \n    // Camera setup\n    vec3 ro = vec3(0.0, 0.0, 4.0);\n    vec3 rd = normalize(vec3(uv, -1.5));\n    \n    // Gentle camera sway\n    ro.xz *= rot(sin(u_time * 0.1) * 0.2);\n    rd.xz *= rot(sin(u_time * 0.1) * 0.2);\n    rd.xy *= rot(cos(u_time * 0.15) * 0.1);\n\n    // Raymarching\n    float t = 0.0;\n    int steps = 0;\n    for (int i = 0; i < 64; i++) {\n        vec3 p = ro + rd * t;\n        float h = map(p);\n        if (h < 0.001 || t > 10.0) break;\n        t += h;\n        steps = i;\n    }\n\n    // Base background gradient (Liquid fluid color)\n    vec3 col = mix(vec3(0.2, 0.0, 0.3), vec3(0.1, 0.0, 0.2), length(uv));\n\n    if (t < 10.0) {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);\n        \n        // Lighting setup\n        vec3 lightPos = vec3(2.0, 3.0, 2.0);\n        vec3 lightDir = normalize(lightPos - p);\n        vec3 viewDir = normalize(ro - p);\n        \n        // Diffuse\n        float diff = max(dot(n, lightDir), 0.0);\n        \n        // Specular\n        vec3 reflectDir = reflect(-lightDir, n);\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n        \n        // Fresnel (Rim lighting for gooey look)\n        float fresnel = pow(1.0 - max(dot(viewDir, n), 0.0), 2.0);\n        \n        // Internal heat glow based on Y position\n        vec3 heatColor = mix(vec3(1.0, 0.1, 0.1), vec3(1.0, 0.8, 0.2), smoothstep(-2.0, 2.0, p.y));\n        \n        // Combine lighting\n        vec3 objCol = heatColor * (diff * 0.6 + 0.4);\n        objCol += vec3(1.0, 0.9, 0.8) * spec;\n        objCol += vec3(0.8, 0.2, 0.5) * fresnel * 1.5;\n        \n        col = objCol;\n    }\n    \n    // Volumetric glow effect based on raymarch steps (fake subsurface scattering)\n    float glow = float(steps) / 64.0;\n    col += vec3(1.0, 0.3, 0.0) * glow * 0.8;\n    \n    // Vignette\n    col *= 1.0 - dot(uv, uv) * 0.5;\n    \n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n\n    gl_FragColor = vec4(col, 1.0);\n}",
      "totalTime": 41131,
      "createdAt": 1763646738194,
      "slug": "lava-lamp",
      "filename": "vibecheck_018e2ce7-7a56-48f7-a3ca-3afd7332a0c6_2e714824-87cf-4fa2-9c7d-2a8bf15fe7d3.json"
    },
    {
      "projectId": "14d551de-462e-451a-8057-9f2eebb86ccf",
      "outputId": "c6bca154-dff3-4969-a17a-358e8940f0e3",
      "prompt": "metal cymatics",
      "mode": "glsl",
      "model": "threePro",
      "srcCode": "precision mediump float;\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n// Calculate the height of the wave pattern at a specific coordinate\nfloat cymaticWave(vec2 p) {\n    float t = u_time * 0.5;\n    float len = length(p);\n    float ang = atan(p.y, p.x);\n    \n    // Base Standing Wave (Radial)\n    float wave = sin(len * 20.0 - t * 4.0);\n    \n    // Angular interference (Chladni figures style)\n    // The frequency changes slowly over time to simulate changing resonance tones\n    float mode = 6.0 + sin(t * 0.2) * 2.0; \n    wave += sin(ang * mode) * cos(len * 12.0);\n    \n    // Linear interference to create grid-like nodal points\n    wave += sin(p.x * 25.0 + t) * sin(p.y * 25.0 - t) * 0.4;\n    \n    // Harmonic detail\n    wave += sin(len * 50.0 - t * 8.0) * 0.1;\n    \n    return wave * 0.5;\n}\n\n// Pseudo-chromatic aberration and iridescence palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid main() {\n    // Normalize coordinates -1 to 1, correcting for aspect ratio\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.y, u_resolution.x);\n    \n    // Calculate Surface Normal using Finite Difference\n    float eps = 0.005;\n    float h = cymaticWave(uv);\n    float h_x = cymaticWave(uv + vec2(eps, 0.0));\n    float h_y = cymaticWave(uv + vec2(0.0, eps));\n    \n    // Construct normal vector from the slope of the wave\n    // The z-component controls the perceived flatness of the metal plate\n    vec3 normal = normalize(vec3(h - h_x, h - h_y, eps * 8.0));\n    \n    // Lighting Setup\n    vec3 viewDir = vec3(0.0, 0.0, 1.0);\n    \n    // Rotating light source\n    vec3 lightDir = normalize(vec3(sin(u_time), cos(u_time), 1.0));\n    \n    // Ambient metallic base\n    vec3 col = vec3(0.15, 0.18, 0.25);\n    \n    // Diffuse lighting\n    float diff = max(dot(normal, lightDir), 0.0);\n    col += diff * vec3(0.2, 0.25, 0.3);\n    \n    // Specular highlights (Sharpness gives the metal look)\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    col += spec * vec3(1.0, 0.9, 0.8); // Golden highlight\n    \n    // Environment Reflection Mapping (Approximation)\n    // Maps the normal angle to a color palette to simulate reflection of an environment\n    float refAngle = dot(normal, viewDir);\n    vec3 envColor = palette(refAngle * 2.0 + u_time * 0.1);\n    \n    // Fresnel effect: Edges are more reflective\n    float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 2.0);\n    col += envColor * fresnel * 2.0;\n    \n    // Add subtle chromatic dispersion based on wave height\n    col.r += h * 0.1;\n    col.b -= h * 0.1;\n    \n    // Vignette\n    float dist = length(uv);\n    col *= smoothstep(1.2, 0.5, dist);\n\n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n    \n    gl_FragColor = vec4(col, 1.0);\n}",
      "totalTime": 54789,
      "createdAt": 1763647025927,
      "slug": "metal-cymatics-1",
      "filename": "vibecheck_14d551de-462e-451a-8057-9f2eebb86ccf_c6bca154-dff3-4969-a17a-358e8940f0e3.json"
    },
    {
      "projectId": "14d551de-462e-451a-8057-9f2eebb86ccf",
      "outputId": "d3e73387-863d-4538-8112-4e8f45780dec",
      "prompt": "metal cymatics",
      "mode": "glsl",
      "model": "threePro",
      "srcCode": "precision mediump float;\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n// Rotate vector\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c) * v;\n}\n\n// Cymatic wave function\nfloat cymatics(vec2 p) {\n    float t = u_time * 0.5;\n    float d = length(p);\n    \n    // Base radial wave (standing wave)\n    float v = sin(d * 30.0 - t * 4.0);\n    \n    // Angular modulation (nodal lines)\n    float angle = atan(p.y, p.x);\n    v *= cos(angle * 6.0 + sin(t * 0.5) * 2.0);\n    \n    // Interference pattern (grid waves)\n    vec2 grid = p * 15.0;\n    v += sin(grid.x + t) * sin(grid.y + t) * 0.5;\n    \n    // Second layer of radial interference\n    v += sin(d * 50.0 + t * 2.0) * 0.2;\n    \n    return v * 0.5; // Amplitude scaling\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution) / min(u_resolution.x, u_resolution.y);\n    \n    // Calculate surface normal using finite differences\n    float epsilon = 0.005;\n    float h = cymatics(uv);\n    float h_x = cymatics(uv + vec2(epsilon, 0.0));\n    float h_y = cymatics(uv + vec2(0.0, epsilon));\n    \n    // Construct normal vector\n    vec3 normal = normalize(vec3(h - h_x, h - h_y, epsilon * 2.0));\n    \n    // Lighting setup\n    vec3 lightPos = vec3(sin(u_time) * 2.0, cos(u_time * 0.7) * 2.0, 2.0);\n    vec3 viewDir = normalize(vec3(uv, -2.0)); // Viewer is above\n    vec3 lightDir = normalize(lightPos - vec3(uv, 0.0));\n    vec3 halfVector = normalize(lightDir - viewDir);\n    \n    // Specular (Phong)\n    float spec = pow(max(dot(normal, halfVector), 0.0), 32.0);\n    \n    // Environment Reflection (Fake chrome)\n    vec3 ref = reflect(viewDir, normal);\n    // Create a procedural environment map using sine waves on the reflection vector\n    vec3 env = vec3(0.5) + 0.5 * cos(ref.xyx * 4.0 + vec3(0.0, 2.0, 4.0) + u_time * 0.2);\n    \n    // Frensel effect for metallic edges\n    float fresnel = pow(1.0 - max(dot(normal, -viewDir), 0.0), 3.0);\n    \n    // Combine for metallic look\n    vec3 col = vec3(0.1); // Base dark metal\n    col += env * 0.8; // Reflection\n    col += vec3(1.0, 0.95, 0.9) * spec * 2.0; // Bright highlights\n    col += fresnel * 0.5;\n    \n    // Add some dispersion/chromatic aberration at the edges of waves\n    col.r += cymatics(uv + vec2(0.002)) * 0.2;\n    col.b -= cymatics(uv - vec2(0.002)) * 0.2;\n\n    // Contrast and vignette\n    col = pow(col, vec3(1.2));\n    col *= 1.0 - length(uv) * 0.4;\n    \n    gl_FragColor = vec4(col, 1.0);\n}",
      "totalTime": 58959,
      "createdAt": 1763647025927,
      "slug": "metal-cymatics-2",
      "filename": "vibecheck_14d551de-462e-451a-8057-9f2eebb86ccf_d3e73387-863d-4538-8112-4e8f45780dec.json"
    },
    {
      "projectId": "3ecb5102-b983-431b-8eda-6c38cca89771",
      "outputId": "018ab913-41cd-4697-9307-8708db078cb6",
      "prompt": "An interactive overhead projector",
      "mode": "p5",
      "model": "threePro",
      "srcCode": "let transparencyLayer;\nlet projectorLight;\nlet sheetX = 0;\nlet sheetY = 0;\nlet isDraggingSheet = false;\nlet dragOffsetX = 0;\nlet dragOffsetY = 0;\n\n// Pen properties\nlet penColor;\nlet penSize = 5;\nlet currentPenIndex = 0;\nlet pens = [\n  { color: [0, 0, 0, 200], label: 'BLK' }, // Black\n  { color: [200, 0, 0, 200], label: 'RED' }, // Red\n  { color: [0, 0, 180, 200], label: 'BLU' }, // Blue\n  { color: [0, 150, 0, 200], label: 'GRN' }  // Green\n];\n\n// Projector visual constants\nlet glassX, glassY, glassW, glassH;\n\nfunction setup() {\n  createCanvas(800, 600);\n  \n  // Define the projector glass area\n  glassW = 500;\n  glassH = 500;\n  glassX = width / 2 - glassW / 2;\n  glassY = height / 2 - glassH / 2;\n\n  // Initialize the transparency sheet (the buffer we draw on)\n  transparencyLayer = createGraphics(600, 600);\n  transparencyLayer.clear(); // Transparent background\n  \n  // Set initial position of the sheet (centered)\n  sheetX = width / 2 - 300;\n  sheetY = height / 2 - 300;\n\n  penColor = color(pens[0].color);\n  \n  cursor(CROSS);\n}\n\nfunction draw() {\n  background(30); // Dark classroom\n\n  // 1. Draw the Projector Base\n  noStroke();\n  fill(50); // Dark grey plastic casing\n  rect(glassX - 40, glassY - 40, glassW + 80, glassH + 80, 20);\n  \n  // 2. Draw the Glass/Light (The Stage)\n  drawProjectorLight();\n\n  // 3. Draw the Transparency Sheet\n  // We simulate the plastic sheet being slightly larger than the drawing area\n  // and slightly milky/reflective\n  push();\n  translate(sheetX, sheetY);\n  \n  // Sheet boundary (The plastic film)\n  stroke(255, 50);\n  strokeWeight(1);\n  fill(255, 10); // Slight milky tint of plastic\n  rect(0, 0, transparencyLayer.width, transparencyLayer.height);\n  \n  // The drawings\n  image(transparencyLayer, 0, 0);\n  pop();\n\n  // 4. Post-Processing / Overlays\n  drawProjectorArmShadow();\n  drawDustMotes();\n  drawVignette();\n  \n  // 5. UI - Marker Tray\n  drawUI();\n}\n\nfunction drawProjectorLight() {\n  // Clip drawing to the glass area\n  push();\n  rectMode(CORNER);\n  // Glow effect for the light\n  drawingContext.shadowBlur = 50;\n  drawingContext.shadowColor = color(255, 255, 240);\n  \n  fill(240, 240, 225); // Bright warm white light\n  rect(glassX, glassY, glassW, glassH, 10);\n  drawingContext.shadowBlur = 0; // Reset shadow\n\n  // Draw Fresnel Lens rings (Concentric circles texture)\n  noFill();\n  stroke(0, 0, 0, 10); // Very faint rings\n  strokeWeight(2);\n  let centerX = glassX + glassW / 2;\n  let centerY = glassY + glassH / 2;\n  for (let r = 0; r < 400; r += 15) {\n    circle(centerX, centerY, r * 2);\n  }\n  pop();\n}\n\nfunction drawProjectorArmShadow() {\n  // Simulates the shadow of the focus head and arm blocking the light\n  push();\n  fill(0, 150);\n  drawingContext.filter = 'blur(20px)';\n  \n  // The arm coming from the side\n  beginShape();\n  vertex(glassX + glassW + 50, glassY + 100);\n  vertex(glassX + glassW - 50, glassY + 120);\n  vertex(glassX + glassW - 50, glassY + glassH - 120);\n  vertex(glassX + glassW + 50, glassY + glassH - 100);\n  endShape(CLOSE);\n\n  // The head shadow (top corner usually)\n  ellipse(glassX + glassW - 80, glassY + 80, 150, 150);\n  pop();\n}\n\nfunction drawVignette() {\n  // Darken edges to simulate looking into a bright light source\n  push();\n  drawingContext.shadowBlur = 0;\n  noFill();\n  strokeWeight(100);\n  stroke(20, 20, 20, 100);\n  rect(-50, -50, width + 100, height + 100);\n  pop();\n}\n\nlet motes = [];\nfunction drawDustMotes() {\n  // Floating dust in the light\n  if (motes.length < 20) {\n    motes.push({\n      x: random(glassX, glassX + glassW),\n      y: random(glassY, glassY + glassH),\n      vx: random(-0.5, 0.5),\n      vy: random(-0.5, 0.5),\n      alpha: random(50, 150)\n    });\n  }\n  \n  noStroke();\n  fill(255);\n  \n  for (let i = motes.length - 1; i >= 0; i--) {\n    let m = motes[i];\n    m.x += m.vx;\n    m.y += m.vy;\n    \n    // Only draw if over the glass\n    if (m.x > glassX && m.x < glassX + glassW && m.y > glassY && m.y < glassY + glassH) {\n       fill(255, m.alpha);\n       circle(m.x, m.y, 2);\n    } else {\n      motes.splice(i, 1);\n    }\n  }\n}\n\nfunction drawUI() {\n  // Draw Marker Tray at the bottom\n  push();\n  translate(50, height - 60);\n  \n  // Tray background\n  fill(40);\n  stroke(60);\n  rect(-10, -10, 300, 60, 5);\n\n  // Markers\n  for (let i = 0; i < pens.length; i++) {\n    let x = i * 60;\n    \n    // Highlight active pen\n    if (i === currentPenIndex) {\n      fill(60);\n      noStroke();\n      rect(x - 5, -5, 50, 50, 5);\n      stroke(255); // White border for active\n    } else {\n      noStroke();\n    }\n    \n    // Pen Body\n    let c = color(pens[i].color);\n    c.setAlpha(255);\n    fill(c);\n    rect(x + 10, 10, 20, 30, 2);\n    \n    // Cap\n    fill(20);\n    rect(x + 10, 0, 20, 10, 2);\n    \n    // Label (Simulate looking down at pen caps)\n    textAlign(CENTER);\n    textSize(10);\n    fill(200);\n    noStroke();\n    text(pens[i].label, x + 20, 55);\n  }\n\n  // Clear Button\n  translate(320, 0);\n  fill(currentPenIndex === -1 ? 80 : 50); // Highlight if hovering (handled by logic below usually, simplified here)\n  stroke(100);\n  rect(0, 0, 60, 40, 5);\n  fill(255);\n  noStroke();\n  textAlign(CENTER, CENTER);\n  text(\"WIPE\", 30, 20);\n  \n  // Instructions\n  textAlign(LEFT);\n  fill(150);\n  text(\"Drag sheet with SHIFT key or Right Click\", 80, 20);\n\n  pop();\n}\n\nfunction mousePressed() {\n  // Check UI Interaction\n  if (mouseY > height - 70 && mouseY < height - 10) {\n     let relativeX = mouseX - 50;\n     \n     // Markers\n     if (relativeX >= 0 && relativeX < 240) {\n       let idx = floor(relativeX / 60);\n       if (idx >= 0 && idx < pens.length) {\n         currentPenIndex = idx;\n         penColor = color(pens[idx].color);\n       }\n       return;\n     }\n     \n     // Wipe Button\n     if (relativeX >= 320 && relativeX <= 380) {\n       transparencyLayer.clear();\n       return;\n     }\n  }\n\n  // Check if starting a drag on the sheet (Holding shift or Right click)\n  let overSheet = (mouseX > sheetX && mouseX < sheetX + transparencyLayer.width && \n                   mouseY > sheetY && mouseY < sheetY + transparencyLayer.height);\n                   \n  if (overSheet && (mouseButton === RIGHT || keyIsDown(SHIFT))) {\n    isDraggingSheet = true;\n    dragOffsetX = mouseX - sheetX;\n    dragOffsetY = mouseY - sheetY;\n    cursor(MOVE);\n  }\n}\n\nfunction mouseDragged() {\n  if (isDraggingSheet) {\n    sheetX = mouseX - dragOffsetX;\n    sheetY = mouseY - dragOffsetY;\n  } else {\n    // Drawing Mode\n    // Calculate coordinates relative to the transparency layer\n    let localX = mouseX - sheetX;\n    let localY = mouseY - sheetY;\n    let pLocalX = pmouseX - sheetX;\n    let pLocalY = pmouseY - sheetY;\n\n    // Only draw if we are roughly over the light area (realistic constraint)\n    // or just enforce drawing on the sheet buffer bounds\n    if (mouseX > glassX && mouseX < glassX + glassW && \n        mouseY > glassY && mouseY < glassY + glassH) {\n          \n      transparencyLayer.stroke(penColor);\n      transparencyLayer.strokeWeight(penSize);\n      transparencyLayer.strokeCap(ROUND);\n      transparencyLayer.strokeJoin(ROUND);\n      \n      // Basic line\n      transparencyLayer.line(pLocalX, pLocalY, localX, localY);\n      \n      // Add a slightly thicker, lower alpha line to simulate ink spread/bleed\n      let bleedColor = color(penColor);\n      bleedColor.setAlpha(20);\n      transparencyLayer.stroke(bleedColor);\n      transparencyLayer.strokeWeight(penSize + 4);\n      transparencyLayer.line(pLocalX, pLocalY, localX, localY);\n    }\n  }\n}\n\nfunction mouseReleased() {\n  isDraggingSheet = false;\n  cursor(CROSS);\n}\n\n// Prevent context menu on right click for better dragging experience\ndocument.oncontextmenu = function() { return false; }",
      "totalTime": 58949,
      "createdAt": 1763647681156,
      "slug": "overhead-projector-1",
      "filename": "vibecheck_3ecb5102-b983-431b-8eda-6c38cca89771_018ab913-41cd-4697-9307-8708db078cb6.json"
    },
    {
      "projectId": "3ecb5102-b983-431b-8eda-6c38cca89771",
      "outputId": "59396b46-e017-40ce-a3ed-c1a19e43e0f3",
      "prompt": "An interactive overhead projector",
      "mode": "p5",
      "model": "threePro",
      "srcCode": "let sheetLayer;\nlet lightLayer;\nlet noiseOffset = 0;\nlet isOn = true;\nlet currentColor;\nlet penSize = 8;\nlet colors = {};\n\nfunction setup() {\n  createCanvas(800, 600);\n  \n  // Create the transparency sheet layer\n  sheetLayer = createGraphics(width, height);\n  sheetLayer.clear();\n  sheetLayer.noFill();\n  sheetLayer.strokeJoin(ROUND);\n  sheetLayer.strokeCap(ROUND);\n  \n  // Define marker colors (simulating wet erase markers)\n  colors = {\n    black: color(20, 20, 30, 200),\n    red: color(200, 20, 20, 200),\n    blue: color(20, 20, 200, 200),\n    green: color(20, 150, 20, 200),\n    eraser: color(0, 0) // Special handling for eraser\n  };\n  currentColor = colors.black;\n  \n  // Pre-render fresnel lens effect to save performance\n  lightLayer = createGraphics(width, height);\n  drawFresnel(lightLayer);\n}\n\nfunction drawFresnel(pg) {\n  pg.background(255, 252, 240); // Warm bright white\n  pg.noFill();\n  pg.stroke(0, 0, 0, 3);\n  pg.strokeWeight(1);\n  let cx = width / 2;\n  let cy = height / 2;\n  let maxRad = dist(0, 0, cx, cy);\n  for (let r = 0; r < maxRad; r += 4) {\n    pg.ellipse(cx, cy, r * 2, r * 2);\n  }\n}\n\nfunction draw() {\n  background(10); // Dark classroom\n\n  if (isOn) {\n    // 1. Draw the Light Stage (The Glass)\n    // Clip to a rounded rectangle to simulate the projector bed\n    push();\n    rectMode(CENTER);\n    fill(20);\n    noStroke();\n    // Projector body/frame\n    rect(width/2, height/2, 760, 560, 10); \n    \n    // The illuminated glass area\n    image(lightLayer, 20, 20, 760, 560);\n    \n    // Add subtle flickering/humming noise\n    noiseOffset += 0.1;\n    let flicker = map(noise(noiseOffset), 0, 1, -5, 5);\n    fill(255, 255, 255, 10 + flicker);\n    rect(width/2, height/2, 760, 560);\n    pop();\n\n    // 2. Draw the Transparency Sheet (User Drawings)\n    image(sheetLayer, 0, 0);\n\n    // 3. Draw Shadows (Hand and Projector Head)\n    drawProjectorHeadShadow();\n    drawHandShadow();\n\n    // 4. Vignette / Glare\n    drawVignette();\n    \n    // 5. UI Instructions (projected softly)\n    drawUI();\n    \n    // 6. Handle Interaction\n    handleDrawing();\n    \n  } else {\n    // OFF state\n    fill(30);\n    textAlign(CENTER, CENTER);\n    textSize(20);\n    text(\"Projector Cooling Down... (Press SPACE to toggle power)\", width/2, height/2);\n  }\n}\n\nfunction handleDrawing() {\n  if (mouseIsPressed && mouseX > 20 && mouseX < width - 20 && mouseY > 20 && mouseY < height - 20) {\n    sheetLayer.strokeWeight(penSize);\n    \n    // Add a little jitter to line to simulate marker friction\n    let jx = random(-0.5, 0.5);\n    let jy = random(-0.5, 0.5);\n    \n    if (keyIsDown(SHIFT)) { // Eraser mode logic if Shift is held (or mapped to color)\n       sheetLayer.erase();\n       sheetLayer.strokeWeight(30);\n       sheetLayer.line(pmouseX, pmouseY, mouseX, mouseY);\n       sheetLayer.noErase();\n    } else {\n      sheetLayer.stroke(currentColor);\n      sheetLayer.line(pmouseX + jx, pmouseY + jy, mouseX + jx, mouseY + jy);\n    }\n  }\n}\n\nfunction drawHandShadow() {\n  // Create a blurry shadow of the hand moving over the projector\n  // The hand shadow is disconnected from the drawing point slightly to simulate height\n  \n  push();\n  noStroke();\n  fill(10, 10, 10, 180); // Dark shadow\n  \n  let handX = mouseX + 15;\n  let handY = mouseY + 25;\n  \n  // Only show shadow if mouse is over the canvas\n  if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {\n    \n    // Blur simulation using multiple circles\n    let shadowSize = 40;\n    for(let i = 0; i < 5; i++) {\n      fill(0, 0, 0, 30);\n      ellipse(handX, handY, shadowSize + (i*4), shadowSize + (i*4));\n    }\n    \n    // Main hand blob (holding a pen shape)\n    fill(0, 0, 0, 220);\n    \n    push();\n    translate(handX, handY);\n    rotate(-QUARTER_PI);\n    ellipse(0, 0, 50, 80); // Hand palm/knuckles\n    ellipse(20, -30, 20, 60); // Finger\n    ellipse(0, -40, 20, 60); // Finger\n    \n    // Pen shadow\n    rotate(QUARTER_PI); // Reset rotation relative to hand\n    stroke(0, 0, 0, 200);\n    strokeWeight(10);\n    line(-10, -10, -50, -50); // Pen stick\n    pop();\n  }\n  pop();\n}\n\nfunction drawProjectorHeadShadow() {\n  // The arm and mirror head that hangs over every overhead projector\n  // Usually casts a hard shadow on one side\n  push();\n  noStroke();\n  \n  // The post shadow (usually corner)\n  fill(10, 10, 10, 220);\n  rect(width - 60, height/2 - 100, 60, 200); // Post on the right\n  \n  // The arm shadow\n  push();\n  translate(width - 60, height/2);\n  rotate(PI/12);\n  rect(-150, -15, 160, 30);\n  \n  // The Head/Lens shadow (trapezoid shape)\n  translate(-160, 0);\n  beginShape();\n  vertex(-20, -40);\n  vertex(40, -40);\n  vertex(40, 40);\n  vertex(-20, 40);\n  endShape(CLOSE);\n  pop();\n  \n  // Blur the edges of the static shadow slightly\n  fill(0, 0, 0, 50);\n  rect(width - 65, height/2 - 105, 70, 210, 10); \n  \n  pop();\n}\n\nfunction drawVignette() {\n  // Simulates the light falloff at corners\n  push();\n  noFill();\n  strokeWeight(2);\n  for (let r = 0; r < 150; r+=5) {\n    let alpha = map(r, 0, 150, 255, 0);\n    stroke(0, 0, 0, alpha * 0.3);\n    rect(width/2, height/2, width - r, height - r, 40);\n  }\n  pop();\n}\n\nfunction drawUI() {\n  push();\n  fill(50, 50, 50, 150);\n  textSize(14);\n  textFont('monospace');\n  textAlign(LEFT, TOP);\n  \n  let x = 40;\n  let y = height - 50;\n  text(\"[1] Black  [2] Red  [3] Blue  [4] Green\", x, y);\n  text(\"[SHIFT] Eraser  [DEL] Clear Sheet  [SPACE] Power\", x, y + 20);\n  \n  // Color Indicator\n  noStroke();\n  if (keyIsDown(SHIFT)) {\n     fill(255);\n     stroke(0);\n     circle(width - 50, height - 40, 30);\n     fill(0);\n     textAlign(CENTER, CENTER);\n     noStroke();\n     text(\"E\", width-50, height-40);\n  } else {\n    fill(currentColor);\n    stroke(255, 100);\n    strokeWeight(2);\n    circle(width - 50, height - 40, 30);\n  }\n  pop();\n}\n\nfunction keyPressed() {\n  if (key === ' ') {\n    isOn = !isOn;\n  }\n  if (!isOn) return;\n  \n  if (key === '1') currentColor = colors.black;\n  if (key === '2') currentColor = colors.red;\n  if (key === '3') currentColor = colors.blue;\n  if (key === '4') currentColor = colors.green;\n  \n  if (keyCode === DELETE || keyCode === BACKSPACE) {\n    // Wipe the transparency with a \"wet\" look before clearing\n    sheetLayer.background(255, 255, 255, 50); \n    sheetLayer.clear();\n  }\n}",
      "totalTime": 56354,
      "createdAt": 1763647681156,
      "slug": "overhead-projector-2",
      "filename": "vibecheck_3ecb5102-b983-431b-8eda-6c38cca89771_59396b46-e017-40ce-a3ed-c1a19e43e0f3.json"
    },
    {
      "projectId": "3ecb5102-b983-431b-8eda-6c38cca89771",
      "outputId": "7b9d9692-a51a-46a6-9fc2-a3d0f6a87e98",
      "prompt": "An interactive overhead projector",
      "mode": "p5",
      "model": "threePro",
      "srcCode": "function setup() {\n  createCanvas(800, 600);\n  \n  // Create the off-screen buffer for the acetate sheet (drawing layer)\n  acetate = createGraphics(800, 600);\n  acetate.clear();\n  \n  // Initialize particles for dust effect\n  for (let i = 0; i < 50; i++) {\n    dust.push(new DustParticle());\n  }\n  \n  // Default marker color (Blue)\n  markerColor = color(0, 0, 200, 150);\n  \n  noCursor();\n}\n\nlet acetate;\nlet markerColor;\nlet dust = [];\nlet lastX, lastY;\n\nfunction draw() {\n  background(10); // Dark room environment\n\n  // --- 1. The Projected Light (Trapezoid/Keystone effect) ---\n  push();\n  translate(width / 2, height / 2);\n  \n  // Glow effect\n  drawingContext.shadowBlur = 100;\n  drawingContext.shadowColor = color(220, 240, 255);\n  \n  noStroke();\n  fill(240, 248, 255); // Slightly blue-ish white light\n  \n  // Draw the main projection area (rounded rect)\n  rectMode(CENTER);\n  rect(0, 0, 700, 500, 20);\n  pop();\n\n  // --- 2. Fresnel Lens Texture (Concentric rings) ---\n  push();\n  translate(width / 2, height / 2);\n  noFill();\n  stroke(0, 0, 0, 5); // Very faint lines\n  strokeWeight(1);\n  for (let r = 0; r < 800; r += 15) {\n    ellipse(0, 0, r, r * 0.8); // Elliptical to match perspective slightly\n  }\n  pop();\n\n  // --- 3. User Interaction (Drawing on the Acetate) ---\n  if (mouseIsPressed) {\n    acetate.stroke(markerColor);\n    acetate.strokeWeight(6);\n    acetate.strokeJoin(ROUND);\n    acetate.strokeCap(ROUND);\n    \n    // Simulate marker ink physics (multiply effect via alpha)\n    if (lastX && lastY) {\n      // Interpolate for smoother lines\n      let d = dist(lastX, lastY, mouseX, mouseY);\n      // Variable speed creates variable ink density\n      let speed = constrain(d, 0, 20);\n      let alphaVal = map(speed, 0, 20, 200, 100);\n      \n      let c = markerColor;\n      c.setAlpha(alphaVal);\n      acetate.stroke(c);\n      acetate.line(lastX, lastY, mouseX, mouseY);\n    }\n  } else {\n    lastX = null;\n    lastY = null;\n  }\n  \n  // Update last positions\n  if (mouseIsPressed) {\n    lastX = mouseX;\n    lastY = mouseY;\n  }\n\n  // --- 4. Render the Acetate Layer ---\n  image(acetate, 0, 0);\n\n  // --- 5. The \"Shadow\" of the Hand/Pen ---\n  // In an overhead projector, the hand hovers over the glass, casting a shadow\n  push();\n  translate(mouseX, mouseY);\n  \n  // Rotate slightly based on movement for a natural feel\n  let angle = map(mouseX, 0, width, -PI/6, PI/6);\n  rotate(angle);\n  \n  // Shadow settings (fuzzy shadow)\n  drawingContext.shadowBlur = 20;\n  drawingContext.shadowColor = 'rgba(0,0,0,0.8)';\n  \n  fill(20); // Dark shadow color\n  noStroke();\n  \n  // Draw a simple pen/hand silhouette shape\n  beginShape();\n  vertex(0, 0); // Tip of pen\n  bezierVertex(10, 10, 20, 50, 25, 200); // Shaft right\n  vertex(-25, 200); // Bottom\n  bezierVertex(-20, 50, -10, 10, 0, 0); // Shaft left\n  endShape(CLOSE);\n  \n  // Draw the actual \"pen\" object on top of the shadow (the object itself blocking light)\n  drawingContext.shadowBlur = 0;\n  \n  // Pen Body\n  if (markerColor.toString().includes(\"200\")) fill(0, 0, 200); // Blue\n  else if (markerColor.toString().includes(\"255, 0, 0\")) fill(200, 0, 0); // Red\n  else if (markerColor.toString().includes(\"0, 150, 0\")) fill(0, 150, 0); // Green\n  else fill(20); // Black\n  \n  beginShape();\n  vertex(0, 0);\n  bezierVertex(10, 10, 20, 50, 25, 200);\n  vertex(-25, 200);\n  bezierVertex(-20, 50, -10, 10, 0, 0);\n  endShape(CLOSE);\n  pop();\n\n  // --- 6. Atmosphere (Floating Dust) ---\n  for (let p of dust) {\n    p.update();\n    p.display();\n  }\n  \n  // --- 7. Vignette / Frame ---\n  // Darken edges to simulate the dark room\n  drawVignette();\n  \n  // --- 8. UI Instructions ---\n  drawUI();\n}\n\nfunction drawUI() {\n  push();\n  fill(100);\n  noStroke();\n  textSize(14);\n  textAlign(LEFT, BOTTOM);\n  text(\"KEYS: [R] Red  [G] Green  [B] Blue  [K] Black  [SPACE] Clear Sheet\", 60, height - 60);\n  pop();\n}\n\nfunction keyPressed() {\n  if (key === ' ' || key === 'c') {\n    // Clear acetate\n    acetate.clear();\n  }\n  if (key === 'r' || key === 'R') {\n    markerColor = color(255, 0, 0, 150);\n  }\n  if (key === 'b' || key === 'B') {\n    markerColor = color(0, 0, 200, 150);\n  }\n  if (key === 'g' || key === 'G') {\n    markerColor = color(0, 150, 0, 150);\n  }\n  if (key === 'k' || key === 'K') {\n    markerColor = color(0, 0, 0, 180);\n  }\n}\n\nfunction drawVignette() {\n  push();\n  blendMode(MULTIPLY);\n  let gradient = drawingContext.createRadialGradient(width/2, height/2, 250, width/2, height/2, 500);\n  gradient.addColorStop(0, 'rgba(0,0,0,0)');\n  gradient.addColorStop(1, 'rgba(0,0,0,0.9)');\n  drawingContext.fillStyle = gradient;\n  rect(0, 0, width, height);\n  pop();\n}\n\nclass DustParticle {\n  constructor() {\n    this.reset();\n    this.y = random(height); // Start randomly\n  }\n  \n  reset() {\n    this.x = random(width);\n    this.y = height + 10;\n    this.size = random(1, 3);\n    this.speed = random(0.2, 1);\n    this.alpha = random(50, 150);\n    this.oscillationOffset = random(TWO_PI);\n  }\n  \n  update() {\n    // Heat rises, dust floats up\n    this.y -= this.speed;\n    // Slight side to side movement\n    this.x += sin(frameCount * 0.01 + this.oscillationOffset) * 0.2;\n    \n    if (this.y < -10) {\n      this.reset();\n    }\n  }\n  \n  display() {\n    push();\n    noStroke();\n    // Dust is illuminated by the light\n    fill(255, 255, 200, this.alpha); \n    ellipse(this.x, this.y, this.size);\n    pop();\n  }\n}",
      "totalTime": 44559,
      "createdAt": 1763647681156,
      "slug": "overhead-projector-3",
      "filename": "vibecheck_3ecb5102-b983-431b-8eda-6c38cca89771_7b9d9692-a51a-46a6-9fc2-a3d0f6a87e98.json"
    },
    {
      "projectId": "815c6d9b-4349-4ef2-99cc-a0dbabdb8944",
      "outputId": "1cb64249-42f6-474e-bf34-080dde3b3a9d",
      "prompt": "An overhead projector",
      "mode": "p5",
      "model": "threePro",
      "srcCode": "function setup() {\n  createCanvas(800, 600);\n  \n  // Create the transparency sheet buffer\n  transparencyLayer = createGraphics(300, 300);\n  transparencyLayer.colorMode(RGB);\n  transparencyLayer.clear();\n  \n  // Initial drawing on the transparency (a crude chart)\n  transparencyLayer.strokeWeight(3);\n  transparencyLayer.stroke(0, 0, 150, 200); // Blue marker\n  transparencyLayer.noFill();\n  transparencyLayer.beginShape();\n  transparencyLayer.vertex(50, 250);\n  transparencyLayer.vertex(100, 200);\n  transparencyLayer.vertex(150, 220);\n  transparencyLayer.vertex(200, 100);\n  transparencyLayer.vertex(250, 50);\n  transparencyLayer.endShape();\n  \n  transparencyLayer.stroke(200, 0, 0, 200); // Red underline\n  transparencyLayer.line(180, 110, 270, 60);\n  transparencyLayer.noStroke();\n  transparencyLayer.fill(0);\n  transparencyLayer.textSize(20);\n  transparencyLayer.text(\"Q4 PROJECTIONS\", 40, 50);\n\n  // Particle system for dust\n  for(let i=0; i<50; i++) {\n    dust.push({\n      x: random(200, 600),\n      y: random(0, 600),\n      size: random(1, 3),\n      speed: random(0.2, 1),\n      offset: random(1000)\n    });\n  }\n}\n\nlet isOn = true;\nlet transparencyLayer;\nlet dust = [];\nlet noiseOffset = 0;\n\n// Projector Geometry\nconst boxX = 400;\nconst boxY = 450;\nconst boxW = 400;\nconst boxH = 280;\nconst lensSize = 260;\n\nfunction draw() {\n  background(30); // Dark room\n  \n  // --- 1. THE WALL (Projection Surface) ---\n  noStroke();\n  fill(50);\n  rect(0, 0, width, 250); // Wall area\n  fill(20);\n  rect(0, 250, width, 350); // Desk/Floor area\n\n  // --- 2. PROJECTION LOGIC ---\n  if (isOn) {\n    push();\n    // Light Beam (Trapezoid)\n    noStroke();\n    // Use additive blending for light\n    blendMode(SCREEN);\n    \n    // The main trapezoid of light on the wall\n    fill(255, 253, 240, 150);\n    beginShape();\n    vertex(150, 20);  // Top Left Wall\n    vertex(650, 20);  // Top Right Wall\n    vertex(600, 230); // Bottom Right Wall\n    vertex(200, 230); // Bottom Left Wall\n    endShape(CLOSE);\n    \n    // The \"Cone\" in the air (subtle volumetric light)\n    fill(255, 255, 255, 15);\n    beginShape();\n    vertex(150, 20);\n    vertex(650, 20);\n    vertex(boxX + 120, boxY - 50); // Convergence near head\n    vertex(boxX - 120, boxY - 50);\n    endShape(CLOSE);\n\n    // Render the transparency content onto the wall\n    // Transform to fit the trapezoid\n    // Since applyMatrix is complex for 4-point distort, we'll map it simply to a rect \n    // positioned within the light area for the effect.\n    tint(255, 255, 255, 220); // Slightly transparent projection\n    // Flip Y visually because mirrors flip images, though usually OHP lenses correct this.\n    // We will just project it straight up.\n    image(transparencyLayer, 200, 30, 400, 200); \n    \n    // Add chromatic aberration / lens blur edges\n    tint(255, 0, 0, 50);\n    image(transparencyLayer, 202, 30, 402, 200);\n    tint(0, 0, 255, 50);\n    image(transparencyLayer, 198, 30, 398, 200);\n    \n    pop();\n\n    // Dust Motes in the light\n    drawDust();\n  }\n\n  // --- 3. THE PROJECTOR MACHINE ---\n  drawProjectorBody();\n\n  // --- 4. INTERACTION INSTRUCTIONS ---\n  drawUI();\n}\n\nfunction drawProjectorBody() {\n  rectMode(CENTER);\n  \n  // Shadow under the box\n  fill(0, 100);\n  rect(boxX + 10, boxY + 10, boxW, boxH, 20);\n\n  // Main Body Case\n  fill(180, 175, 160); // Retro Beige\n  stroke(100, 95, 85);\n  strokeWeight(2);\n  rect(boxX, boxY, boxW, boxH, 10);\n  \n  // Front Vent Grills\n  stroke(120, 115, 105);\n  for(let i = -150; i < 150; i+=15) {\n    line(boxX + i, boxY + 100, boxX + i, boxY + 120);\n  }\n  \n  // Power Switch Area\n  fill(150, 145, 135);\n  rect(boxX - 150, boxY + 110, 40, 30, 5);\n  \n  // Power Switch (Clickable)\n  if (isOn) {\n    fill(255, 100, 100); // Lit Red\n    boxShadow(boxX - 150, boxY + 110, 20, 15, 255, 50, 50, 20); // Glow\n  } else {\n    fill(100, 50, 50); // Dark Red\n  }\n  noStroke();\n  rect(boxX - 150, boxY + 110, 25, 15, 2);\n  \n  // --- THE GLASS STAGE ---\n  // Rim\n  stroke(140);\n  fill(200);\n  rect(boxX, boxY - 20, lensSize + 20, lensSize + 20, 5);\n  \n  // The Glass / Fresnel Lens\n  if (isOn) {\n    fill(240, 250, 255); // Bright white-blue\n  } else {\n    fill(100, 110, 120); // Dark glass\n  }\n  noStroke();\n  rect(boxX, boxY - 20, lensSize, lensSize);\n  \n  // Fresnel Rings Texture\n  noFill();\n  stroke(0, 20);\n  strokeWeight(1);\n  for (let r = 10; r < lensSize; r += 15) {\n    ellipse(boxX, boxY - 20, r, r);\n  }\n  \n  // --- TRANSPARENCY ON GLASS ---\n  // We draw the buffer directly onto the glass area\n  imageMode(CENTER);\n  image(transparencyLayer, boxX, boxY - 20, lensSize, lensSize);\n  \n  // --- ARM & HEAD ---\n  \n  // The Post (Right side)\n  fill(160, 155, 140);\n  stroke(80);\n  strokeWeight(2);\n  rect(boxX + 180, boxY - 100, 30, 300); // Vertical post\n  \n  // Focus Knob\n  fill(50);\n  rect(boxX + 180, boxY - 150, 35, 20);\n  \n  // The Arm extending over the glass\n  fill(170, 165, 150);\n  beginShape();\n  vertex(boxX + 165, boxY - 240);\n  vertex(boxX + 165, boxY - 200);\n  vertex(boxX, boxY - 180); // Connection to head\n  vertex(boxX, boxY - 220);\n  endShape(CLOSE);\n  \n  // The Head (Lens/Mirror Housing)\n  // Shadow of the head on the glass (if light is coming from below, shadow goes up, \n  // but usually ambient light casts a shadow down on the glass)\n  if (isOn) {\n    fill(0, 80);\n    noStroke();\n    ellipse(boxX, boxY - 20, 80, 80); // Silhouette of head blocking light\n  }\n  \n  // Physical Head Unit\n  stroke(80);\n  fill(150, 145, 130);\n  rect(boxX, boxY - 220, 100, 80, 5); // Main box\n  \n  // Lens opening pointing down\n  fill(20);\n  ellipse(boxX, boxY - 220, 60, 60);\n  \n  // Mirror angle indication\n  stroke(200, 200, 255, 100);\n  line(boxX - 30, boxY - 240, boxX + 30, boxY - 200);\n  \n  imageMode(CORNER); // Reset\n}\n\nfunction drawDust() {\n  noStroke();\n  fill(255, 200);\n  \n  noiseOffset += 0.01;\n  \n  for(let p of dust) {\n    // Update\n    p.y -= p.speed;\n    let n = noise(p.x * 0.01, p.y * 0.01, noiseOffset);\n    let wiggle = map(n, 0, 1, -1, 1);\n    \n    // Wrap around\n    if (p.y < 0) {\n      p.y = 250; // Reset to bottom of projection\n      p.x = random(200, 600);\n    }\n    \n    // Draw only if within light cone (rough approximation)\n    if (p.y < 230 && p.x > 150 && p.x < 650) {\n      ellipse(p.x + wiggle * 20, p.y, p.size);\n    }\n  }\n}\n\nfunction drawUI() {\n  fill(255);\n  noStroke();\n  textSize(14);\n  textAlign(LEFT, BOTTOM);\n  text(\"OVERHEAD PROJECTOR SIMULATOR\", 20, height - 40);\n  \n  fill(180);\n  textSize(12);\n  text(\"- Click Red Switch to Toggle Power\", 20, height - 25);\n  text(\"- Drag Mouse on Glass to Draw (Marker)\", 20, height - 10);\n  text(\"- Press 'C' to Clear Transparency\", 250, height - 10);\n  \n  // Marker Cursor Logic\n  if (mouseX > boxX - lensSize/2 && mouseX < boxX + lensSize/2 &&\n      mouseY > (boxY-20) - lensSize/2 && mouseY < (boxY-20) + lensSize/2) {\n    cursor(CROSS);\n  } else {\n    cursor(ARROW);\n  }\n}\n\n// Helper for simple glow\nfunction boxShadow(x, y, w, h, r, g, b, a) {\n  push();\n  blendMode(ADD);\n  noStroke();\n  for (let i = 0; i < 10; i++) {\n    fill(r, g, b, a - i*2);\n    rect(x, y, w + i*2, h + i*2, 5);\n  }\n  pop();\n}\n\nfunction mousePressed() {\n  // Toggle Switch Check\n  // Switch rect: boxX - 150, boxY + 110, 25, 15\n  let swX = boxX - 150;\n  let swY = boxY + 110;\n  if (mouseX > swX - 20 && mouseX < swX + 20 && mouseY > swY - 15 && mouseY < swY + 15) {\n    isOn = !isOn;\n    // Sound effect visual cue could go here\n  }\n}\n\nfunction mouseDragged() {\n  // Drawing on Transparency\n  // Map mouse coordinates relative to the glass stage to the buffer coordinates\n  let glassLeft = boxX - lensSize/2;\n  let glassTop = (boxY - 20) - lensSize/2;\n  \n  // Check bounds\n  if (mouseX > glassLeft && mouseX < glassLeft + lensSize &&\n      mouseY > glassTop && mouseY < glassTop + lensSize) {\n        \n    let bx = map(mouseX, glassLeft, glassLeft + lensSize, 0, transparencyLayer.width);\n    let by = map(mouseY, glassTop, glassTop + lensSize, 0, transparencyLayer.height);\n    let pbx = map(pmouseX, glassLeft, glassLeft + lensSize, 0, transparencyLayer.width);\n    let pby = map(pmouseY, glassTop, glassTop + lensSize, 0, transparencyLayer.height);\n    \n    transparencyLayer.stroke(0, 0, 0, 200); // Black Vis-a-Vis marker\n    transparencyLayer.strokeWeight(4);\n    transparencyLayer.line(pbx, pby, bx, by);\n  }\n}\n\nfunction keyPressed() {\n  if (key === 'c' || key === 'C') {\n    transparencyLayer.clear();\n  }\n}",
      "totalTime": 63399,
      "createdAt": 1763647344954,
      "slug": "overhead-projector-4",
      "filename": "vibecheck_815c6d9b-4349-4ef2-99cc-a0dbabdb8944_1cb64249-42f6-474e-bf34-080dde3b3a9d.json"
    },
    {
      "projectId": "b50978a9-95ad-41c1-b9ca-548722375915",
      "outputId": "1f38f7b7-117d-4b0c-8744-5489c2b71566",
      "prompt": "An interactive overhead projector with oil and water to mix on it",
      "mode": "p5",
      "model": "threePro",
      "srcCode": "let blobs = [];\nlet canvas;\nlet vignette;\n\nfunction setup() {\n  canvas = createCanvas(800, 600);\n  \n  // Create a vignette mask for the projector feel\n  vignette = createGraphics(width, height);\n  vignette.noFill();\n  for (let r = 0; r < width * 1.5; r += 5) {\n    let alpha = map(r, 300, width * 0.8, 0, 255, true);\n    vignette.stroke(0, 0, 0, alpha);\n    vignette.strokeWeight(5);\n    vignette.ellipse(width / 2, height / 2, r, r * 0.75); // Aspect ratio for oval light\n  }\n\n  // Initialize with some oil blobs\n  for (let i = 0; i < 25; i++) {\n    addBlob(random(width * 0.3, width * 0.7), random(height * 0.3, height * 0.7));\n  }\n}\n\nfunction draw() {\n  // 1. Projector Light Source Background\n  background(245, 245, 240);\n  \n  // Draw Fresnel lens pattern (concentric rings typical of overhead projectors)\n  noFill();\n  stroke(220, 220, 220);\n  strokeWeight(1);\n  let centerX = width / 2;\n  let centerY = height / 2;\n  for (let r = 0; r < width * 1.2; r += 15) {\n    ellipse(centerX, centerY, r, r * 0.8);\n  }\n\n  // 2. Physics and Simulation\n  handlePhysics();\n\n  // 3. Draw the Fluids\n  // We use MULTIPLY blend mode to simulate transparent colored oils on a lightbox\n  blendMode(MULTIPLY);\n  \n  for (let b of blobs) {\n    b.display();\n  }\n\n  // 4. Overlay and UI\n  blendMode(BLEND);\n  \n  // Draw the vignette to darken corners (simulate the projector head shadow/falloff)\n  image(vignette, 0, 0);\n  \n  // Dust/Scratch noise for analog feel\n  drawNoise();\n\n  // UI Text\n  fill(50);\n  noStroke();\n  textAlign(LEFT, BOTTOM);\n  textSize(14);\n  text(\"INTERACTIVE PROJECTOR: Click to drop oil. Drag to stir fluids.\", 20, height - 20);\n}\n\nfunction addBlob(x, y) {\n  let r = random(30, 70);\n  // CMY Color palette for subtractive mixing look\n  let colors = [\n    color(0, 255, 255, 180),   // Cyan\n    color(255, 0, 255, 180),   // Magenta\n    color(255, 255, 0, 180),   // Yellow\n    color(0, 100, 200, 180),   // Deep Blue\n    color(200, 50, 50, 180)    // Red\n  ];\n  let c = random(colors);\n  blobs.push(new Blob(x, y, r, c));\n}\n\nfunction mousePressed() {\n  addBlob(mouseX, mouseY);\n}\n\nfunction mouseDragged() {\n  // Stirring mechanic\n  let mouseVel = createVector(mouseX - pmouseX, mouseY - pmouseY);\n  mouseVel.mult(0.5); // Strength of stir\n  \n  for (let b of blobs) {\n    let d = dist(mouseX, mouseY, b.pos.x, b.pos.y);\n    if (d < b.r * 2) {\n      b.vel.add(mouseVel);\n    }\n  }\n}\n\nfunction handlePhysics() {\n  for (let i = 0; i < blobs.length; i++) {\n    let a = blobs[i];\n    \n    // Movement\n    a.update();\n    \n    // Blob-to-Blob interaction (Soft collision / surface tension)\n    for (let j = i + 1; j < blobs.length; j++) {\n      let b = blobs[j];\n      let distVec = p5.Vector.sub(b.pos, a.pos);\n      let d = distVec.mag();\n      let minDist = (a.r + b.r) * 0.6; // Allow some overlap for \"merging\" look\n      \n      if (d < minDist && d > 0) {\n        let force = distVec.copy().normalize();\n        let overlap = minDist - d;\n        \n        // Repulsion force (immiscibility)\n        force.mult(overlap * 0.05);\n        \n        a.vel.sub(force);\n        b.vel.add(force);\n        \n        // Surface tension attraction (clumping)\n        if (d > minDist * 0.5) {\n            let attract = distVec.copy().normalize().mult(0.01);\n            a.vel.add(attract);\n            b.vel.sub(attract);\n        }\n      }\n    }\n  }\n}\n\nfunction drawNoise() {\n  // Adds subtle grain to look like an old projection\n  loadPixels();\n  // Optimization: Only noise a fraction of pixels to save performance\n  for (let i = 0; i < 1000; i++) {\n    let x = floor(random(width));\n    let y = floor(random(height));\n    let col = random(200, 255);\n    set(x, y, color(col, col, col, 100));\n  }\n  updatePixels();\n}\n\nclass Blob {\n  constructor(x, y, r, c) {\n    this.pos = createVector(x, y);\n    this.vel = createVector(random(-1, 1), random(-1, 1));\n    this.acc = createVector(0, 0);\n    this.r = r;\n    this.c = c;\n    // Inner wobble offset\n    this.noiseOffset = random(1000);\n  }\n\n  update() {\n    // Viscosity/Friction\n    this.vel.mult(0.96);\n    \n    // Gentle centering force (gravity of the glass dip)\n    let center = createVector(width/2, height/2);\n    let dir = p5.Vector.sub(center, this.pos);\n    dir.normalize();\n    dir.mult(0.02); \n    this.acc.add(dir);\n\n    this.vel.add(this.acc);\n    this.pos.add(this.vel);\n    this.acc.mult(0);\n\n    // Walls\n    if (this.pos.x < this.r) { this.pos.x = this.r; this.vel.x *= -0.5; }\n    if (this.pos.x > width - this.r) { this.pos.x = width - this.r; this.vel.x *= -0.5; }\n    if (this.pos.y < this.r) { this.pos.y = this.r; this.vel.y *= -0.5; }\n    if (this.pos.y > height - this.r) { this.pos.y = height - this.r; this.vel.y *= -0.5; }\n    \n    this.noiseOffset += 0.01;\n  }\n\n  display() {\n    noStroke();\n    \n    // Draw main blob\n    fill(this.c);\n    \n    // Deform the shape slightly based on velocity for organic fluid feel\n    push();\n    translate(this.pos.x, this.pos.y);\n    \n    // Rotate based on movement\n    let angle = this.vel.heading();\n    rotate(angle);\n    \n    // Stretch based on speed\n    let speed = this.vel.mag();\n    let stretch = map(speed, 0, 10, 1, 1.5);\n    \n    // Draw organic shape\n    beginShape();\n    for (let a = 0; a < TWO_PI; a += 0.2) {\n      let xoff = map(cos(a), -1, 1, 0, 2);\n      let yoff = map(sin(a), -1, 1, 0, 2);\n      // Perlin noise for wobbly edges\n      let r = this.r * map(noise(xoff + this.noiseOffset, yoff + this.noiseOffset), 0, 1, 0.8, 1.1);\n      \n      // Stretch in X direction (direction of movement)\n      let sx = r * stretch;\n      let sy = r / stretch; // Maintain roughly same area\n      \n      let x = sx * cos(a);\n      let y = sy * sin(a);\n      vertex(x, y);\n    }\n    endShape(CLOSE);\n    \n    // Draw inner \"highlight\" to simulate thickness/caustics\n    fill(255, 255, 255, 50);\n    ellipse(this.r * -0.2, this.r * -0.2, this.r * 0.5, this.r * 0.4);\n    \n    pop();\n  }\n}",
      "totalTime": 49414,
      "createdAt": 1763647665107,
      "slug": "oil-water-1",
      "filename": "vibecheck_b50978a9-95ad-41c1-b9ca-548722375915_1f38f7b7-117d-4b0c-8744-5489c2b71566.json"
    },
    {
      "projectId": "b50978a9-95ad-41c1-b9ca-548722375915",
      "outputId": "7cfe70b3-e048-4d55-b187-bc475be4b4cd",
      "prompt": "An interactive overhead projector with oil and water to mix on it",
      "mode": "p5",
      "model": "threePro",
      "srcCode": "let blobs = [];\nlet colorPalette = [];\n\nfunction setup() {\n  createCanvas(800, 600);\n  \n  // Define a translucent, oil-dye palette (Cyan, Magenta, Yellow, Purple, Red)\n  // Using RGBA for transparency logic, but blending will be handled by MULTIPLY\n  colorPalette = [\n    color(0, 255, 255, 200),   // Cyan\n    color(255, 0, 255, 200),   // Magenta\n    color(255, 255, 0, 200),   // Yellow\n    color(100, 0, 255, 180),   // Deep Purple\n    color(255, 50, 50, 180),   // Red\n    color(0, 200, 100, 180)    // Emerald\n  ];\n\n  // Create initial set of oil blobs\n  let initialBlobs = 15;\n  for (let i = 0; i < initialBlobs; i++) {\n    blobs.push(new OilBlob(random(width), random(height)));\n  }\n  \n  noStroke();\n}\n\nfunction draw() {\n  // 1. The Light Source (Background)\n  background(250, 248, 240); // Very bright, slightly warm white (projector bulb)\n\n  // 2. Physics & Interaction Step\n  for (let i = 0; i < blobs.length; i++) {\n    blobs[i].update();\n    blobs[i].checkEdges();\n    \n    // Inter-blob repulsion (simulating surface tension/oil immiscibility)\n    for (let j = i + 1; j < blobs.length; j++) {\n      blobs[i].interact(blobs[j]);\n    }\n    \n    // Mouse interaction (Stirring)\n    if (mouseIsPressed || dist(mouseX, mouseY, pmouseX, pmouseY) > 5) {\n      blobs[i].stir(mouseX, mouseY);\n    }\n  }\n\n  // 3. Render Blobs with Subtractive Mixing\n  // This simulates colored transparency films or oil dyes overlapping on a light table\n  blendMode(MULTIPLY);\n  \n  for (let b of blobs) {\n    b.display();\n  }\n\n  // 4. Projector Lens Artifacts (Vignette & Dust)\n  blendMode(BLEND); // Reset blend mode for overlays\n  \n  // Vignette\n  drawVignette();\n  \n  // Subtle dust/scratches\n  drawDust();\n}\n\nfunction drawVignette() {\n  // Create a radial gradient approximation using concentric circles with low alpha\n  // to darken the edges like an old overhead projector lens\n  noFill();\n  strokeWeight(40);\n  let maxDist = dist(0, 0, width/2, height/2);\n  for (let r = maxDist * 0.8; r < maxDist * 1.5; r += 30) {\n    let alpha = map(r, maxDist * 0.8, maxDist * 1.5, 0, 100);\n    stroke(20, 20, 30, alpha);\n    rectMode(CENTER);\n    // Drawing a rounded rect that approximates the screen edge\n    rect(width/2, height/2, width + (r-maxDist), height + (r-maxDist), 200);\n  }\n  rectMode(CORNER); // Reset\n  noStroke();\n}\n\nfunction drawDust() {\n  // Simulates dust on the glass plate\n  randomSeed(frameCount / 20); // Change slowly\n  fill(50, 50, 50, 40);\n  for(let i = 0; i < 10; i++){\n    let x = random(width);\n    let y = random(height);\n    circle(x, y, random(1, 3));\n  }\n}\n\nfunction mousePressed() {\n  // Add a new small drop of ink/oil on click\n  let b = new OilBlob(mouseX, mouseY);\n  b.r = 0; // Start small\n  b.targetR = random(30, 80);\n  blobs.push(b);\n  \n  // Cap max blobs for performance\n  if (blobs.length > 25) {\n    blobs.shift();\n  }\n}\n\nclass OilBlob {\n  constructor(x, y) {\n    this.pos = createVector(x, y);\n    this.vel = p5.Vector.random2D().mult(random(0.2, 1.0));\n    this.acc = createVector(0, 0);\n    \n    this.targetR = random(40, 120);\n    this.r = this.targetR; // Radius\n    \n    this.color = random(colorPalette);\n    \n    // Perlin noise offsets for shape wobble\n    this.noiseOffset = random(1000);\n    this.noiseStep = random(0.003, 0.01);\n    \n    // How \"wobbly\" the blob is\n    this.wobbleAmount = random(10, 30);\n  }\n\n  update() {\n    this.vel.add(this.acc);\n    this.vel.limit(3); // Viscous fluid limit\n    this.pos.add(this.vel);\n    this.acc.mult(0);\n    \n    // Slowly grow to target size (for newly clicked blobs)\n    this.r = lerp(this.r, this.targetR, 0.05);\n    \n    // Evolve shape\n    this.noiseOffset += this.noiseStep;\n  }\n\n  stir(mx, my) {\n    let mousePos = createVector(mx, my);\n    let dir = p5.Vector.sub(this.pos, mousePos);\n    let d = dir.mag();\n    \n    // If mouse is close, swirl around or push\n    if (d < 150) {\n      dir.normalize();\n      let force = 20 / (d + 1); // Stronger when closer\n      \n      // Add some rotational stir component\n      let stirDir = createVector(-dir.y, dir.x); // Perpendicular\n      \n      // Mix push and spin\n      this.acc.add(dir.mult(force * 0.5));\n      this.acc.add(stirDir.mult(force * 0.5));\n    }\n  }\n\n  interact(other) {\n    // Soft collision / repulsion\n    let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);\n    let minDist = (this.r + other.r) * 0.7; // Allow some visual overlap (mixing)\n\n    if (d < minDist && d > 0) {\n      let forceVec = p5.Vector.sub(this.pos, other.pos);\n      forceVec.normalize();\n      // Repel force based on overlap\n      let forceMag = (minDist - d) * 0.02; \n      \n      this.acc.add(forceVec.mult(forceMag));\n      other.acc.sub(forceVec); // Newton's 3rd law\n    }\n  }\n\n  checkEdges() {\n    let buffer = -50;\n    if (this.pos.x < buffer) {\n      this.pos.x = width - buffer;\n    } else if (this.pos.x > width - buffer) {\n      this.pos.x = buffer;\n    }\n    \n    if (this.pos.y < buffer) {\n      this.pos.y = height - buffer;\n    } else if (this.pos.y > height - buffer) {\n      this.pos.y = buffer;\n    }\n  }\n\n  display() {\n    fill(this.color);\n    \n    beginShape();\n    // Draw vertices based on polar coordinates + noise\n    // Use a high number of vertices for smooth liquid look\n    let numVerts = 60; \n    for (let a = 0; a < TWO_PI; a += TWO_PI / numVerts) {\n      // Noise space is circular to make the loop seamless\n      let xoff = map(cos(a), -1, 1, 0, 2); \n      let yoff = map(sin(a), -1, 1, 0, 2);\n      \n      // Get noise value for this angle at this time\n      let n = noise(xoff + this.noiseOffset, yoff + this.noiseOffset);\n      \n      // Map noise to radius deviation\n      let offsetR = map(n, 0, 1, -this.wobbleAmount, this.wobbleAmount);\n      let r = this.r + offsetR;\n      \n      let x = this.pos.x + r * cos(a);\n      let y = this.pos.y + r * sin(a);\n      \n      curveVertex(x, y);\n    }\n    \n    // Close the curve loop smoothly\n    // Need to repeat the first few vertices at the end for curveVertex\n    for (let i = 0; i < 3; i++) {\n      let a = i * (TWO_PI / numVerts);\n      let xoff = map(cos(a), -1, 1, 0, 2);\n      let yoff = map(sin(a), -1, 1, 0, 2);\n      let n = noise(xoff + this.noiseOffset, yoff + this.noiseOffset);\n      let offsetR = map(n, 0, 1, -this.wobbleAmount, this.wobbleAmount);\n      let r = this.r + offsetR;\n      let x = this.pos.x + r * cos(a);\n      let y = this.pos.y + r * sin(a);\n      curveVertex(x, y);\n    }\n    endShape();\n    \n    // Add a \"glint\" or \"bubble\" inside for depth\n    fill(255, 255, 255, 100);\n    let glintSize = this.r * 0.2;\n    let glintX = this.pos.x + this.r * 0.3;\n    let glintY = this.pos.y - this.r * 0.3;\n    \n    // Only draw glint if blob is big enough\n    if(this.r > 20) {\n        ellipse(glintX, glintY, glintSize, glintSize * 0.6);\n    }\n  }\n}",
      "totalTime": 55171,
      "createdAt": 1763647665107,
      "slug": "oil-water-2",
      "filename": "vibecheck_b50978a9-95ad-41c1-b9ca-548722375915_7cfe70b3-e048-4d55-b187-bc475be4b4cd.json"
    },
    {
      "projectId": "d8514bb3-12bb-454a-ab18-91a851df45f7",
      "outputId": "42fbb162-cc63-4c3e-812d-64a78b5a3cee",
      "prompt": "An interactive overhead projector where you drop oil and water in different colors and then it shines on the wall",
      "mode": "p5",
      "model": "threePro",
      "srcCode": "let drops = [];\nlet textureGraphics;\nlet selectedType = 'oil'; // 'oil' or 'water'\n\nfunction setup() {\n  createCanvas(800, 600);\n  colorMode(HSB, 360, 100, 100, 100);\n  \n  // Create a static texture for the Fresnel lens look/dust\n  textureGraphics = createGraphics(width, height);\n  textureGraphics.noFill();\n  textureGraphics.stroke(255, 5);\n  textureGraphics.strokeWeight(2);\n  let cx = width / 2;\n  let cy = height / 2;\n  for (let r = 0; r < 500; r += 15) {\n    textureGraphics.circle(cx, cy, r * 2);\n  }\n  \n  // Add some random dust\n  for(let i=0; i<200; i++){\n    textureGraphics.stroke(0, 10);\n    textureGraphics.strokeWeight(random(1,3));\n    textureGraphics.point(random(width), random(height));\n  }\n\n  // Instructions\n  noStroke();\n}\n\nfunction draw() {\n  background(10); // Dark room wall\n\n  // Draw the projector light square\n  push();\n  fill(240, 235, 255); // Bright white light\n  rectMode(CENTER);\n  // Soft glow behind the projection\n  drawingContext.shadowBlur = 50;\n  drawingContext.shadowColor = color(255);\n  rect(width/2, height/2, 700, 500, 20);\n  drawingContext.shadowBlur = 0; \n  pop();\n\n  // Draw the Fresnel lens texture\n  image(textureGraphics, 0, 0);\n\n  // Update and Draw Fluids\n  // We use a blur filter to make circles look like liquid merging\n  push();\n  \n  // This creates the gooey effect\n  drawingContext.filter = 'blur(12px) contrast(1.5)'; \n  \n  for (let i = drops.length - 1; i >= 0; i--) {\n    let d = drops[i];\n    d.update();\n    d.display();\n    d.checkBounds();\n    \n    // Interaction with other drops\n    for (let j = i - 1; j >= 0; j--) {\n      let other = drops[j];\n      d.collide(other);\n    }\n  }\n  pop();\n\n  // Draw Vignette / Projector Arm Shadow\n  drawVignette();\n  \n  // Interaction Logic\n  if (mouseIsPressed) {\n    if(frameCount % 5 === 0) {\n      addDrop(mouseX, mouseY);\n    }\n  }\n\n  // UI Instructions\n  drawUI();\n}\n\nfunction addDrop(x, y) {\n  // Ensure drops stay within the light area approx\n  if (x > 80 && x < 720 && y > 80 && y < 520) {\n    let type = selectedType;\n    // Auto-toggle or random variation for fun if user doesn't select\n    if(keyIsPressed === false && mouseIsPressed) {\n       // If just clicking, vary size and color slightly\n    }\n    \n    let radius = random(15, 40);\n    let col;\n    \n    if (type === 'oil') {\n      // Oil colors: Yellows, Oranges, Reds, dense\n      col = color(random(0, 60), 90, 90, 80); \n    } else {\n      // Water/Dye colors: Blues, Cyans, Purples, translucent\n      col = color(random(160, 280), 80, 90, 60);\n    }\n    \n    drops.push(new Drop(x, y, radius, col, type));\n  }\n  \n  // Cap number of particles for performance\n  if(drops.length > 150) {\n    drops.shift();\n  }\n}\n\nfunction keyPressed() {\n  if (key === '1' || key === 'o') selectedType = 'oil';\n  if (key === '2' || key === 'w') selectedType = 'water';\n  if (key === 'c') drops = []; // Clear\n}\n\nclass Drop {\n  constructor(x, y, r, col, type) {\n    this.pos = createVector(x, y);\n    this.vel = p5.Vector.random2D().mult(0.5);\n    this.r = 0; // animate in\n    this.targetR = r;\n    this.col = col;\n    this.type = type;\n  }\n\n  update() {\n    // Grow animation\n    if (this.r < this.targetR) {\n      this.r = lerp(this.r, this.targetR, 0.1);\n    }\n\n    this.pos.add(this.vel);\n    \n    // Heat convection / slight drift\n    this.vel.add(p5.Vector.random2D().mult(0.02));\n    \n    // Friction\n    this.vel.mult(0.98);\n  }\n\n  display() {\n    noStroke();\n    fill(this.col);\n    // If it's oil, it might have a \"rim\" or be denser. \n    // If water, it mixes more.\n    circle(this.pos.x, this.pos.y, this.r * 2);\n    \n    // Add a highlight to make it look wet (only visible because of blur context)\n    fill(255, 30);\n    circle(this.pos.x - this.r*0.3, this.pos.y - this.r*0.3, this.r * 0.5);\n  }\n\n  checkBounds() {\n    // Stay inside the \"glass\"\n    let margin = 60;\n    if (this.pos.x < margin) { this.pos.x = margin; this.vel.x *= -1; }\n    if (this.pos.x > width - margin) { this.pos.x = width - margin; this.vel.x *= -1; }\n    if (this.pos.y < margin) { this.pos.y = margin; this.vel.y *= -1; }\n    if (this.pos.y > height - margin) { this.pos.y = height - margin; this.vel.y *= -1; }\n  }\n\n  collide(other) {\n    let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);\n    let minDist = this.r + other.r;\n\n    if (d < minDist) {\n      // Calculate repulsion force\n      let angle = atan2(other.pos.y - this.pos.y, other.pos.x - this.pos.x);\n      let force = 0.05; // Soft force\n      \n      // Oil and Water repel strongly\n      if (this.type !== other.type) {\n        force = 0.2; \n        // Also insure they don't overlap visually as much (immiscible)\n        let overlap = minDist - d;\n        if (overlap > 0) {\n          let adjust = overlap * 0.05;\n          let dir = p5.Vector.sub(other.pos, this.pos).normalize();\n          other.pos.add(dir.mult(adjust));\n          this.pos.sub(dir.mult(adjust));\n        }\n      } \n      \n      let targetX = cos(angle) * force;\n      let targetY = sin(angle) * force;\n\n      this.vel.x -= targetX;\n      this.vel.y -= targetY;\n      other.vel.x += targetX;\n      other.vel.y += targetY;\n    }\n  }\n}\n\nfunction drawVignette() {\n  // Heavy vignette to simulate the dark room and lens falloff\n  beginShape();\n  fill(0, 0, 0, 0);\n  vertex(0,0);\n  vertex(width, 0);\n  vertex(width, height);\n  vertex(0, height);\n  \n  // Cutout\n  beginContour();\n  vertex(50, 50);\n  vertex(50, height-50);\n  vertex(width-50, height-50);\n  vertex(width-50, 50);\n  endContour();\n  endShape(CLOSE);\n  \n  // Soft edges using gradient fake (multiple strokes)\n  noFill();\n  for(let i=0; i<60; i++){\n    stroke(0, map(i, 0, 60, 255, 0));\n    strokeWeight(1);\n    rectMode(CENTER);\n    rect(width/2, height/2, 700 + i, 500 + i, 20 + i/2);\n  }\n  \n  // Projector arm shadow\n  fill(10, 220);\n  noStroke();\n  rect(width - 40, height/2, 80, height);\n}\n\nfunction drawUI() {\n  push();\n  fill(50);\n  textAlign(LEFT, BOTTOM);\n  textSize(14);\n  text(\"OVERHEAD PROJECTOR SIMULATOR\", 60, height - 60);\n  \n  fill(80);\n  textSize(12);\n  text(\"Drag Mouse to drop fluid.\", 60, height - 40);\n  text(\"Keys: [1] Oil (Warm) | [2] Water (Cool) | [C] Clear\", 60, height - 25);\n  \n  // Current selection indicator\n  textAlign(RIGHT, BOTTOM);\n  fill(selectedType === 'oil' ? color(30, 100, 80) : color(200, 100, 80));\n  text(\"Current Dropper: \" + selectedType.toUpperCase(), width - 70, height - 30);\n  pop();\n}",
      "totalTime": 53272,
      "createdAt": 1763648178379,
      "slug": "oil-water-3",
      "filename": "vibecheck_d8514bb3-12bb-454a-ab18-91a851df45f7_42fbb162-cc63-4c3e-812d-64a78b5a3cee.json"
    },
    {
      "projectId": "d8514bb3-12bb-454a-ab18-91a851df45f7",
      "outputId": "962624c9-f771-473b-8c7a-695a47a735bb",
      "prompt": "An interactive overhead projector where you drop oil and water in different colors and then it shines on the wall",
      "mode": "p5",
      "model": "threePro",
      "srcCode": "let drops = [];\nlet colors;\nlet projectorMask;\n\nfunction setup() {\n  createCanvas(800, 600);\n  \n  // Define a palette of overhead transparency ink colors\n  colors = [\n    color(255, 0, 100, 200),   // Magenta\n    color(0, 200, 255, 200),   // Cyan\n    color(255, 220, 0, 200),   // Yellow\n    color(100, 0, 255, 200),   // Purple\n    color(0, 255, 100, 200),   // Lime\n    color(20, 20, 20, 220)     // Black Oil\n  ];\n\n  // Create the vignette mask for the projector look\n  projectorMask = createGraphics(width, height);\n  projectorMask.background(0);\n  projectorMask.erase();\n  projectorMask.noStroke();\n  // Draw a soft circular opening\n  let maxR = height * 0.9;\n  for (let r = maxR; r > 0; r -= 2) {\n    let alpha = map(r, 0, maxR, 255, 0);\n    projectorMask.fill(0, 0, 0, alpha);\n    projectorMask.ellipse(width / 2, height / 2, r * 1.3, r);\n  }\n  projectorMask.noErase();\n}\n\nfunction draw() {\n  // 1. The Wall (Background)\n  background(245, 245, 240);\n  \n  // 2. Projector Light Grain\n  loadPixels();\n  for (let i = 0; i < pixels.length; i += 4) {\n    // Add subtle noise to simulate wall texture/analog projection grain\n    if (random(1) > 0.5) {\n      let noiseVal = random(-5, 5);\n      pixels[i] = constrain(pixels[i] + noiseVal, 0, 255);\n      pixels[i+1] = constrain(pixels[i+1] + noiseVal, 0, 255);\n      pixels[i+2] = constrain(pixels[i+2] + noiseVal, 0, 255);\n    }\n  }\n  updatePixels();\n\n  // 3. Draw the Fluids\n  // We use MULTIPLY blend mode to simulate transparent inks layering over light\n  blendMode(MULTIPLY);\n  \n  for (let i = drops.length - 1; i >= 0; i--) {\n    let d = drops[i];\n    d.update();\n    d.display();\n    \n    // Remove drops that drift too far or get too small\n    if (d.isDead()) {\n      drops.splice(i, 1);\n    }\n  }\n\n  // 4. Apply Projector Vignette (Mask)\n  // Switch back to blend to draw the darkness around the light\n  blendMode(BLEND);\n  image(projectorMask, 0, 0);\n\n  // 5. Instructions\n  fill(150);\n  noStroke();\n  textSize(12);\n  textAlign(LEFT, BOTTOM);\n  text(\"CLICK & DRAG to drop fluids. KEYS 1-6 to change colors.\", 20, height - 20);\n  \n  // Simluated dust motes in the projector light\n  drawDust();\n}\n\nfunction mouseDragged() {\n  // Rate limiter for spawning\n  if (frameCount % 3 === 0) {\n    addDrop();\n  }\n}\n\nfunction mousePressed() {\n  addDrop();\n}\n\nfunction addDrop() {\n  // Pick color based on some randomness but favored by selection logic could go here\n  // For now, random from palette or specific logic\n  let colIdx = floor(random(colors.length));\n  \n  // If holding keys 1-6, force color\n  if (keyIsDown(49)) colIdx = 0; // 1\n  if (keyIsDown(50)) colIdx = 1; // 2\n  if (keyIsDown(51)) colIdx = 2; // 3\n  if (keyIsDown(52)) colIdx = 3; // 4\n  if (keyIsDown(53)) colIdx = 4; // 5\n  if (keyIsDown(54)) colIdx = 5; // 6 - Oil\n\n  let isOil = (colIdx === 5); // The black/dark one behaves like oil\n  \n  drops.push(new FluidDrop(mouseX, mouseY, colors[colIdx], isOil));\n}\n\nfunction drawDust() {\n  stroke(255, 50);\n  strokeWeight(1);\n  for(let i=0; i<5; i++) {\n    let x = random(width);\n    let y = random(height);\n    // Only draw if inside the light roughly\n    let d = dist(x, y, width/2, height/2);\n    if(d < height/2) {\n      point(x, y);\n    }\n  }\n}\n\nclass FluidDrop {\n  constructor(x, y, col, isOil) {\n    this.pos = createVector(x, y);\n    this.isOil = isOil;\n    \n    // Oil moves slower, expands less. Water spreads out.\n    this.vel = p5.Vector.random2D().mult(random(0.2, 0.5));\n    this.radius = 1; \n    this.maxRadius = random(30, 80);\n    if (this.isOil) this.maxRadius = random(10, 40);\n    \n    this.col = col;\n    this.noiseOffset = random(1000);\n    this.noiseStep = random(0.005, 0.02);\n    this.life = 255;\n    this.age = 0;\n  }\n\n  update() {\n    this.age++;\n    \n    // Grow logic\n    if (this.radius < this.maxRadius) {\n      this.radius += (this.isOil ? 0.5 : 1.5);\n    }\n\n    // Movement: Slowly drift and follow a flow field based on Perlin noise\n    let angle = noise(this.pos.x * 0.002, this.pos.y * 0.002, frameCount * 0.001) * TWO_PI * 2;\n    let flow = p5.Vector.fromAngle(angle);\n    flow.mult(this.isOil ? 0.2 : 0.5); // Water flows faster\n    \n    this.pos.add(this.vel);\n    this.pos.add(flow);\n    \n    // Slowly rot\n    this.noiseOffset += this.noiseStep;\n    \n    // Heat effect: everything slowly rises or spreads out\n    // Real projectors get hot, causing convection\n    this.pos.y -= 0.1;\n  }\n\n  display() {\n    noStroke();\n    fill(this.col);\n    \n    push();\n    translate(this.pos.x, this.pos.y);\n    \n    beginShape();\n    // Draw a blob using noise\n    let resolution = 30; // vertices per shape\n    for (let i = 0; i <= resolution; i++) {\n      let angle = map(i, 0, resolution, 0, TWO_PI);\n      \n      // Noise creates the wobbly \"liquid\" edge\n      // We map the noise to the radius\n      let xoff = map(cos(angle), -1, 1, 0, 2);\n      let yoff = map(sin(angle), -1, 1, 0, 2);\n      \n      // Time affects the wobble\n      let n = noise(xoff + this.noiseOffset, yoff + this.noiseOffset, frameCount * 0.01);\n      \n      // Oil keeps its shape more (less wobble), water distorts more\n      let distortion = this.isOil ? 10 : 30; \n      let r = this.radius + map(n, 0, 1, -distortion, distortion);\n      \n      // Calculate vertex\n      let x = r * cos(angle);\n      let y = r * sin(angle);\n      \n      curveVertex(x, y);\n    }\n    endShape(CLOSE);\n    \n    // Specular highlight for oil to make it look shiny/viscous\n    if (this.isOil) {\n      fill(255, 100);\n      ellipse(-this.radius/3, -this.radius/3, this.radius/2, this.radius/3);\n    }\n    \n    pop();\n  }\n\n  isDead() {\n    // Kill if way off screen\n    return (this.pos.x < -100 || this.pos.x > width + 100 || \n            this.pos.y < -100 || this.pos.y > height + 100);\n  }\n}",
      "totalTime": 57821,
      "createdAt": 1763648178379,
      "slug": "oil-water-4",
      "filename": "vibecheck_d8514bb3-12bb-454a-ab18-91a851df45f7_962624c9-f771-473b-8c7a-695a47a735bb.json"
    },
    {
      "projectId": "d8514bb3-12bb-454a-ab18-91a851df45f7",
      "outputId": "abd76830-facb-4535-b557-092886d4d943",
      "prompt": "An interactive overhead projector where you drop oil and water in different colors and then it shines on the wall",
      "mode": "p5",
      "model": "threePro",
      "srcCode": "let blobs = [];\nlet textureLayer;\nlet baseColors;\n\nfunction setup() {\n  createCanvas(800, 600);\n  \n  // Define a psychedelic/liquid light show palette\n  baseColors = [\n    color(255, 0, 100, 200),   // Magenta\n    color(0, 200, 255, 200),   // Cyan\n    color(255, 200, 0, 200),   // Yellow\n    color(100, 0, 255, 200),   // Purple\n    color(0, 255, 100, 200)    // Lime\n  ];\n\n  // Create a static texture for the \"Projector Wall\" feel (dust + vignette)\n  textureLayer = createGraphics(width, height);\n  textureLayer.noStroke();\n  \n  // Add Vignette\n  for (let r = 0; r < width * 1.2; r += 5) {\n    let alpha = map(r, 0, width * 1.2, 0, 255);\n    textureLayer.fill(20, 15, 10, alpha * 0.1); // Very subtle dark rim\n    textureLayer.ellipse(width / 2, height / 2, r, r * 0.75);\n  }\n  \n  // Add Dust/Grain\n  textureLayer.loadPixels();\n  for (let i = 0; i < textureLayer.width; i++) {\n    for (let j = 0; j < textureLayer.height; j++) {\n      if (random(1) > 0.98) {\n        let index = (i + j * textureLayer.width) * 4;\n        textureLayer.pixels[index] = 0;\n        textureLayer.pixels[index + 1] = 0;\n        textureLayer.pixels[index + 2] = 0;\n        textureLayer.pixels[index + 3] = random(20, 50); // slight dust\n      }\n    }\n  }\n  textureLayer.updatePixels();\n  \n  // Initialize with a few drops\n  for(let i=0; i<5; i++) {\n    addBlob(random(width), random(height), false);\n  }\n}\n\nfunction draw() {\n  // 1. The Light Source (Background)\n  background(250, 248, 240); \n  \n  // 2. Update and Draw Blobs\n  // We use blendMode MULTIPLY to simulate ink/oil subtractive color mixing\n  blendMode(MULTIPLY);\n  \n  for (let i = blobs.length - 1; i >= 0; i--) {\n    let b = blobs[i];\n    b.update();\n    b.checkEdges();\n    b.display();\n    \n    // Interactions between blobs\n    for (let j = i - 1; j >= 0; j--) {\n      let other = blobs[j];\n      b.collide(other);\n    }\n  }\n\n  // 3. Overlay the projector texture (Dust/Vignette)\n  blendMode(BLEND);\n  image(textureLayer, 0, 0);\n  \n  // 4. UI Instructions\n  noStroke();\n  fill(50);\n  textAlign(CENTER);\n  textSize(14);\n  text(\"CLICK to drop OIL  |  SHIFT+CLICK to drop WATER  |  Wait for settling\", width/2, height - 20);\n}\n\nfunction mousePressed() {\n  let isWater = keyIsDown(SHIFT);\n  addBlob(mouseX, mouseY, isWater);\n}\n\nfunction mouseDragged() {\n  // Allow dragging to pour liquid\n  if (frameCount % 5 === 0) {\n    let isWater = keyIsDown(SHIFT);\n    addBlob(mouseX + random(-10, 10), mouseY + random(-10, 10), isWater);\n  }\n}\n\nfunction addBlob(x, y, isWater) {\n  let r = random(20, 60);\n  let c;\n  \n  if (isWater) {\n    // Water is clear but distorts (we represent it as light grey/white displacing others)\n    c = color(240, 240, 255, 150);\n    r *= 1.5; // Water blobs are often bigger/spread out\n  } else {\n    c = random(baseColors);\n  }\n  \n  blobs.push(new Blob(x, y, r, c, isWater));\n  \n  // Cap performance\n  if (blobs.length > 100) {\n    blobs.shift();\n  }\n}\n\nclass Blob {\n  constructor(x, y, r, c, isWater) {\n    this.pos = createVector(x, y);\n    this.vel = p5.Vector.random2D().mult(0.5);\n    this.acc = createVector(0, 0);\n    this.r = r; // Target radius\n    this.currentR = 0; // Animation start radius\n    this.color = c;\n    this.isWater = isWater;\n    this.id = random(1000);\n    this.noiseOffset = random(1000);\n  }\n\n  update() {\n    // Grow effect on spawn\n    if (this.currentR < this.r) {\n      this.currentR = lerp(this.currentR, this.r, 0.1);\n    }\n\n    // Add subtle organic drift (convection currents)\n    this.acc.add(p5.Vector.fromAngle(noise(this.pos.x * 0.01, this.pos.y * 0.01, frameCount * 0.005) * TWO_PI).mult(0.02));\n\n    // Apply physics\n    this.vel.add(this.acc);\n    this.vel.limit(2); // Viscosity limit\n    this.pos.add(this.vel);\n    this.acc.mult(0);\n    \n    // Friction\n    this.vel.mult(0.98);\n  }\n\n  collide(other) {\n    let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);\n    let minDist = (this.currentR + other.currentR) * 0.6; // Allow some overlap for mixing look\n\n    if (d < minDist) {\n      // Calculate repulsion force\n      let angle = atan2(other.pos.y - this.pos.y, other.pos.x - this.pos.x);\n      let force = p5.Vector.fromAngle(angle);\n      \n      // Water repels oil more strongly (immiscible fluids)\n      let magnitude = 0.05;\n      if (this.isWater || other.isWater) {\n        magnitude = 0.15; \n      }\n      \n      force.mult(magnitude);\n      \n      this.acc.sub(force); // Push away\n      other.acc.add(force); // Push away\n      \n      // \"Surface Tension\" Jiggle\n      this.noiseOffset += 0.05;\n    }\n  }\n\n  checkEdges() {\n    let buffer = this.currentR;\n    if (this.pos.x < buffer) this.acc.x += 0.1;\n    if (this.pos.x > width - buffer) this.acc.x -= 0.1;\n    if (this.pos.y < buffer) this.acc.y += 0.1;\n    if (this.pos.y > height - buffer) this.acc.y -= 0.1;\n  }\n\n  display() {\n    noStroke();\n    fill(this.color);\n    \n    push();\n    translate(this.pos.x, this.pos.y);\n    \n    // Draw organic shape using noise\n    beginShape();\n    let resolution = 30; // vertices per blob\n    for (let a = 0; a < TWO_PI; a += TWO_PI / resolution) {\n      let xoff = map(cos(a), -1, 1, 0, 2);\n      let yoff = map(sin(a), -1, 1, 0, 2);\n      \n      // Noise makes the blob wobble\n      let offset = map(noise(xoff + this.noiseOffset, yoff + this.noiseOffset, frameCount * 0.01), 0, 1, 0.8, 1.2);\n      \n      let r = this.currentR * offset;\n      let x = r * cos(a);\n      let y = r * sin(a);\n      vertex(x, y);\n    }\n    endShape(CLOSE);\n    \n    // Add a \"highlight\" to simulate surface reflection/thickness\n    if (!this.isWater) {\n      fill(255, 255, 255, 50);\n      ellipse(this.currentR * 0.2, -this.currentR * 0.2, this.currentR * 0.4, this.currentR * 0.3);\n    }\n    \n    pop();\n  }\n}",
      "totalTime": 40898,
      "createdAt": 1763648178379,
      "slug": "oil-water-5",
      "filename": "vibecheck_d8514bb3-12bb-454a-ab18-91a851df45f7_abd76830-facb-4535-b557-092886d4d943.json"
    },
    {
      "projectId": "d8514bb3-12bb-454a-ab18-91a851df45f7",
      "outputId": "ae318897-5d8e-4566-8b06-6bb2711b64b3",
      "prompt": "An interactive overhead projector where you drop oil and water in different colors and then it shines on the wall",
      "mode": "p5",
      "model": "threePro",
      "srcCode": "function setup() {\n  createCanvas(800, 600);\n  pixelDensity(1);\n  \n  // Pre-generate a noise texture for the \"wall\" grain\n  noiseLayer = createGraphics(width, height);\n  noiseLayer.noStroke();\n  noiseLayer.loadPixels();\n  for (let i = 0; i < noiseLayer.pixels.length; i += 4) {\n    let val = random(200, 255);\n    noiseLayer.pixels[i] = val;\n    noiseLayer.pixels[i + 1] = val;\n    noiseLayer.pixels[i + 2] = val;\n    noiseLayer.pixels[i + 3] = 30; // Low alpha\n  }\n  noiseLayer.updatePixels();\n}\n\nlet drops = [];\nlet noiseLayer;\nlet colorPalette = [];\n\nfunction draw() {\n  // 1. Projector Light Background (Hotspot center, vignette edges)\n  background(240, 238, 230);\n  \n  // Draw the light focus\n  noStroke();\n  let ctx = drawingContext;\n  let grad = ctx.createRadialGradient(width / 2, height / 2, 100, width / 2, height / 2, 500);\n  grad.addColorStop(0, 'rgba(255, 255, 255, 1)');\n  grad.addColorStop(0.6, 'rgba(240, 240, 235, 0.5)');\n  grad.addColorStop(1, 'rgba(100, 100, 100, 0.2)');\n  ctx.fillStyle = grad;\n  rect(0, 0, width, height);\n\n  // 2. Interaction: Add Drops\n  if (mouseIsPressed) {\n    if (frameCount % 5 === 0) { // Limit spawn rate\n      let type = (mouseButton === right) ? 'oil' : 'ink';\n      // Vibrant transparency colors\n      let c;\n      if (type === 'oil') {\n        // Oil: Yellows, Golds, Darks\n        let r = random(1);\n        if (r < 0.6) c = color(220, 180, 20, 200);\n        else if (r < 0.9) c = color(100, 80, 10, 220);\n        else c = color(50, 20, 60, 180);\n      } else {\n        // Ink/Water: Cyan, Magenta, Blue\n        let timeHue = (frameCount * 2) % 360;\n        colorMode(HSB);\n        c = color(timeHue, 80, 90, 0.8); // High saturation, transparency handles alpha later\n        colorMode(RGB);\n      }\n      \n      drops.push(new Drop(mouseX, mouseY, c, type));\n    }\n  }\n\n  // 3. Update and Draw Drops\n  // Use MULTIPLY blend mode to simulate transparency sheets/liquid mixing\n  blendMode(MULTIPLY);\n  \n  for (let i = drops.length - 1; i >= 0; i--) {\n    let d = drops[i];\n    d.update();\n    d.interact(drops);\n    d.display();\n    \n    // Remove drops that drift too far\n    if (d.pos.x < -100 || d.pos.x > width + 100 || d.pos.y < -100 || d.pos.y > height + 100) {\n      drops.splice(i, 1);\n    }\n  }\n  \n  // 4. Post-Processing\n  blendMode(BLEND);\n  \n  // Apply the wall grain texture\n  image(noiseLayer, 0, 0);\n  \n  // Simulation of the \"Lens\" focus ring and dust\n  drawLensEffects();\n}\n\nclass Drop {\n  constructor(x, y, col, type) {\n    this.pos = createVector(x, y);\n    this.vel = p5.Vector.random2D().mult(0.5); // Initial spread\n    this.acc = createVector(0, 0);\n    this.maxSize = random(30, 90);\n    this.r = 1; // Start small\n    this.col = col;\n    this.type = type; // 'oil' or 'ink'\n    this.noiseOffset = random(1000);\n    this.wobble = random(0.05, 0.1);\n  }\n\n  update() {\n    // Grow\n    if (this.r < this.maxSize) {\n      this.r = lerp(this.r, this.maxSize, 0.05);\n    }\n\n    // Thermal convection / drift\n    // Oil moves differently than water\n    let speed = (this.type === 'oil') ? 0.002 : 0.005;\n    let angle = noise(this.pos.x * 0.005, this.pos.y * 0.005, frameCount * speed) * TWO_PI * 2;\n    let flow = p5.Vector.fromAngle(angle).mult(0.2);\n    \n    // Add heat rising effect\n    flow.add(createVector(0, -0.05));\n    \n    this.vel.add(flow);\n    this.vel.limit(1); // Terminal velocity\n    this.pos.add(this.vel);\n    \n    this.noiseOffset += 0.01;\n  }\n\n  interact(others) {\n    // Simple separation logic (Surface tension)\n    for (let other of others) {\n      if (other !== this) {\n        let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);\n        let minDist = (this.r + other.r) * 0.6; // Allow some overlap for blending\n        \n        if (d < minDist && d > 0) {\n          let pushVec = p5.Vector.sub(this.pos, other.pos);\n          pushVec.normalize();\n          \n          // Oil and water repel more strongly\n          let force = (this.type !== other.type) ? 0.1 : 0.02; \n          \n          // Inverse square dropoff\n          pushVec.mult(force * (minDist - d));\n          this.pos.add(pushVec);\n        }\n      }\n    }\n  }\n\n  display() {\n    push();\n    translate(this.pos.x, this.pos.y);\n    \n    // Create gradient for 3D liquid look\n    let ctx = drawingContext;\n    let gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.r);\n    \n    // Convert P5 color to RGBA string for gradient\n    let c = this.col;\n    let r = red(c);\n    let g = green(c);\n    let b = blue(c);\n    \n    // Center is lighter (light passing through thickest part of convex lens shape)\n    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.2)`); \n    gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.6)`);\n    // Edges are darker (refraction/meniscus)\n    gradient.addColorStop(1, `rgba(${r*0.6}, ${g*0.6}, ${b*0.6}, 0.9)`);\n    \n    ctx.fillStyle = gradient;\n    noStroke();\n\n    // Draw organic shape\n    beginShape();\n    for (let a = 0; a < TWO_PI; a += 0.2) {\n      let offset = map(noise(cos(a) + 1, sin(a) + 1, this.noiseOffset), 0, 1, -this.r * this.wobble, this.r * this.wobble);\n      let r = this.r + offset;\n      let x = r * cos(a);\n      let y = r * sin(a);\n      vertex(x, y);\n    }\n    endShape(CLOSE);\n    \n    // Add a tiny specular highlight (reflection of the bulb)\n    fill(255, 255, 255, 150);\n    circle(-this.r * 0.3, -this.r * 0.3, this.r * 0.2);\n    \n    pop();\n  }\n}\n\nfunction drawLensEffects() {\n  // Chromatic aberration on the edges (Projector lens quality)\n  push();\n  noFill();\n  strokeWeight(400);\n  stroke(0, 0, 0, 20);\n  ellipse(width/2, height/2, width * 1.8, height * 1.8);\n  pop();\n  \n  // Text\n  fill(80);\n  noStroke();\n  textAlign(LEFT, TOP);\n  textSize(14);\n  text(\"OVERHEAD PROJECTOR SIM\", 20, 20);\n  textSize(10);\n  text(\"Left Click: Colored Ink | Right Click: Oil\", 20, 40);\n}\n\n// Handle right click preventing context menu\ndocument.oncontextmenu = function() { return false; }",
      "totalTime": 42500,
      "createdAt": 1763648178379,
      "slug": "oil-water-6",
      "filename": "vibecheck_d8514bb3-12bb-454a-ab18-91a851df45f7_ae318897-5d8e-4566-8b06-6bb2711b64b3.json"
    },
    {
      "projectId": "d8514bb3-12bb-454a-ab18-91a851df45f7",
      "outputId": "d1f09eb0-9042-45ba-b6ef-8a67249ec8df",
      "prompt": "An interactive overhead projector where you drop oil and water in different colors and then it shines on the wall",
      "mode": "p5",
      "model": "threePro",
      "srcCode": "let blobs = [];\nlet fluidType = 'water'; // 'water' or 'oil'\nlet selectedColor;\nlet pg; // The \"slide\" buffer\nlet wallTexture;\nlet vibrationOffset = 0;\n\nfunction setup() {\n  createCanvas(800, 600);\n  \n  // Create off-screen buffer for the liquid simulation\n  pg = createGraphics(800, 600);\n  pg.noStroke();\n  \n  // Pre-generate wall noise texture for realism\n  wallTexture = createGraphics(800, 600);\n  wallTexture.background(240);\n  wallTexture.loadPixels();\n  for (let i = 0; i < wallTexture.width; i+=2) {\n    for (let j = 0; j < wallTexture.height; j+=2) {\n      let n = noise(i * 0.01, j * 0.01);\n      let grain = random(-10, 10);\n      let c = color(230 + n * 20 + grain);\n      wallTexture.set(i, j, c);\n      wallTexture.set(i+1, j, c);\n      wallTexture.set(i, j+1, c);\n      wallTexture.set(i+1, j+1, c);\n    }\n  }\n  wallTexture.updatePixels();\n  \n  // Initial colors\n  selectedColor = color(0, 200, 255, 150); // Cyan water\n}\n\nfunction draw() {\n  // 1. Physics Update\n  updateBlobs();\n  vibrationOffset += 0.1;\n\n  // 2. Draw the Liquids onto the \"Slide\" (pg)\n  pg.clear();\n  pg.background(255, 255, 255, 0); // Transparent background\n  \n  // Draw a bright light circle (the projector lens area)\n  pg.push();\n  pg.fill(255, 255, 240); // Slightly warm light\n  pg.noStroke();\n  pg.ellipse(width/2, height/2, 550, 550);\n  pg.pop();\n\n  // Draw fluids\n  // We draw them with a multiply-like effect by managing alpha and layering\n  for (let b of blobs) {\n    b.display(pg);\n  }\n\n  // 3. Render to Main Canvas (The Wall)\n  background(20); // Dark room surrounding the projection\n  \n  // Draw the wall texture\n  image(wallTexture, 0, 0);\n  \n  // Blend the slide onto the wall\n  // We use MULTIPLY to simulate transparent ink blocking light\n  blendMode(MULTIPLY);\n  \n  // Add slight chromatic aberration / heat shimmer shake\n  let shakeX = noise(vibrationOffset) * 2 - 1;\n  let shakeY = noise(vibrationOffset + 100) * 2 - 1;\n  \n  // Draw the projection\n  image(pg, shakeX, shakeY);\n  \n  blendMode(BLEND);\n\n  // 4. Overlay Vignette and Lens effects to sell the \"Projector\" look\n  drawProjectorOverlay();\n  \n  // 5. UI\n  drawUI();\n  \n  // Add blobs if mouse is pressed\n  if (mouseIsPressed && mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {\n    if (frameCount % 5 === 0) {\n      addBlob(mouseX, mouseY);\n    }\n  }\n}\n\nfunction drawProjectorOverlay() {\n  // Dark vignette\n  noFill();\n  for (let r = 550; r < 900; r += 20) {\n    let alpha = map(r, 550, 900, 0, 255);\n    stroke(10, 10, 10, alpha);\n    strokeWeight(20);\n    ellipse(width/2, height/2, r, r);\n  }\n  \n  // Hotspot in the center\n  noStroke();\n  fill(255, 255, 255, 30);\n  ellipse(width/2, height/2, 200, 200);\n}\n\nfunction drawUI() {\n  fill(255);\n  noStroke();\n  textSize(14);\n  textAlign(LEFT, TOP);\n  text(\"Controls:\", 20, 20);\n  text(\"[1] Blue Water\", 20, 40);\n  text(\"[2] Pink Water\", 20, 60);\n  text(\"[3] Yellow Oil\", 20, 80);\n  text(\"[4] Black Oil\", 20, 100);\n  text(\"[Space] Clear Slide\", 20, 120);\n  text(\"Click & Drag to drop fluid\", 20, 140);\n  \n  // Current selection indicator\n  fill(selectedColor);\n  stroke(255);\n  ellipse(180, 28, 15, 15);\n  fill(255);\n  noStroke();\n  text(fluidType.toUpperCase(), 200, 22);\n}\n\nfunction keyPressed() {\n  if (key === '1') {\n    fluidType = 'water';\n    selectedColor = color(0, 200, 255, 180); // Cyan\n  } else if (key === '2') {\n    fluidType = 'water';\n    selectedColor = color(255, 0, 150, 180); // Magenta\n  } else if (key === '3') {\n    fluidType = 'oil';\n    selectedColor = color(240, 230, 0, 200); // Yellow\n  } else if (key === '4') {\n    fluidType = 'oil';\n    selectedColor = color(40, 40, 40, 220); // Dark glob\n  } else if (key === ' ') {\n    blobs = [];\n  }\n}\n\nfunction addBlob(x, y) {\n  // Constrain to lens area\n  let d = dist(x, y, width/2, height/2);\n  if (d < 270) {\n    let r = random(15, 30);\n    blobs.push(new Blob(x, y, r, selectedColor, fluidType));\n  }\n}\n\nfunction updateBlobs() {\n  // Limit number of blobs for performance\n  if (blobs.length > 150) {\n    blobs.splice(0, 1);\n  }\n\n  for (let i = 0; i < blobs.length; i++) {\n    blobs[i].update();\n    \n    // Check interactions with other blobs\n    for (let j = i + 1; j < blobs.length; j++) {\n      blobs[i].interact(blobs[j]);\n    }\n    \n    // Stirring with mouse (if not clicking)\n    if (!mouseIsPressed) {\n       let d = dist(mouseX, mouseY, blobs[i].pos.x, blobs[i].pos.y);\n       if (d < 50) {\n         let force = createVector(blobs[i].pos.x - mouseX, blobs[i].pos.y - mouseY);\n         force.setMag(2);\n         blobs[i].applyForce(force);\n       }\n    }\n  }\n}\n\nclass Blob {\n  constructor(x, y, r, c, type) {\n    this.pos = createVector(x, y);\n    this.vel = createVector(random(-0.5, 0.5), random(-0.5, 0.5));\n    this.acc = createVector(0, 0);\n    this.r = r; // Radius\n    this.baseR = r;\n    this.color = c;\n    this.type = type; // 'oil' or 'water'\n    this.oscOffset = random(1000);\n  }\n\n  applyForce(force) {\n    this.acc.add(force);\n  }\n\n  interact(other) {\n    let dir = p5.Vector.sub(this.pos, other.pos);\n    let d = dir.mag();\n    let combinedR = (this.r + other.r) * 0.85; // Allow some overlap for merging look\n\n    if (d < combinedR && d > 0) {\n      let forceMag = 0;\n      \n      // Physics Logic:\n      // Oil and Water repel each other strongly (Immiscible)\n      // Like fluids repel gently to maintain volume but clump\n      \n      if (this.type !== other.type) {\n        // Strong repulsion\n        forceMag = map(d, 0, combinedR, 1.5, 0); \n      } else {\n        // Same type: Softer repulsion (squishy)\n        forceMag = map(d, 0, combinedR, 0.4, 0);\n        \n        // Cohesion: If they are very close, slightly attract to simulate surface tension\n        // But for this simulation, just pushing apart prevents stacking is usually enough\n      }\n      \n      dir.setMag(forceMag);\n      this.applyForce(dir);\n      other.applyForce(dir.mult(-1));\n    }\n  }\n\n  update() {\n    // Friction / Viscosity\n    this.vel.add(this.acc);\n    this.vel.mult(0.92); // High drag -> thick liquid\n    this.pos.add(this.vel);\n    this.acc.mult(0);\n\n    // Breathing effect for organic look\n    this.r = this.baseR + sin(frameCount * 0.1 + this.oscOffset) * 1.5;\n\n    // Bounds within the lens circle\n    let center = createVector(width/2, height/2);\n    let distToCenter = this.pos.dist(center);\n    let limit = 275 - this.r;\n    \n    if (distToCenter > limit) {\n      let pushBack = p5.Vector.sub(center, this.pos);\n      pushBack.setMag(0.5);\n      this.applyForce(pushBack);\n    }\n  }\n\n  display(p) {\n    p.push();\n    // Create a radial gradient feel for 3D volume\n    // P5 doesn't have native radial gradients easily, so we stack circles\n    p.noStroke();\n    \n    let c = this.color;\n    \n    // Blob body\n    p.fill(c);\n    p.ellipse(this.pos.x, this.pos.y, this.r * 2, this.r * 2);\n    \n    // Highlight (Simulate the light refraction on the edge)\n    let hOffset = this.r * 0.3;\n    p.fill(255, 255, 255, 50);\n    p.ellipse(this.pos.x - hOffset, this.pos.y - hOffset, this.r * 0.8, this.r * 0.8);\n    \n    // Oil has a sharper highlight, water is softer\n    if (this.type === 'oil') {\n      p.fill(255, 255, 255, 150);\n      p.ellipse(this.pos.x + hOffset, this.pos.y + hOffset, this.r * 0.4, this.r * 0.4);\n    }\n    \n    p.pop();\n  }\n}",
      "totalTime": 48891,
      "createdAt": 1763648178379,
      "slug": "oil-water-7",
      "filename": "vibecheck_d8514bb3-12bb-454a-ab18-91a851df45f7_d1f09eb0-9042-45ba-b6ef-8a67249ec8df.json"
    },
    {
      "projectId": "d8514bb3-12bb-454a-ab18-91a851df45f7",
      "outputId": "fc4384cd-4283-4899-9b2f-d83edc295aab",
      "prompt": "An interactive overhead projector where you drop oil and water in different colors and then it shines on the wall",
      "mode": "p5",
      "model": "threePro",
      "srcCode": "let blobs = [];\nlet maxBlobs = 60;\nlet blobTexture;\nlet wallTexture;\nlet instructionFade = 255;\n\nfunction setup() {\n  createCanvas(800, 600);\n  \n  // Pre-render a soft radial gradient for the blobs to ensure performance\n  blobTexture = createGraphics(200, 200);\n  blobTexture.noFill();\n  for (let r = 100; r > 0; r -= 2) {\n    let alpha = map(r, 0, 100, 255, 0);\n    // Cubic ease in for softer edges\n    alpha = pow(alpha / 255, 2) * 255;\n    blobTexture.fill(255, alpha);\n    blobTexture.noStroke();\n    blobTexture.ellipse(100, 100, r * 2, r * 2);\n  }\n\n  // Generate static wall noise texture\n  wallTexture = createGraphics(width, height);\n  wallTexture.loadPixels();\n  for (let i = 0; i < wallTexture.width; i++) {\n    for (let j = 0; j < wallTexture.height; j++) {\n      let idx = (i + j * wallTexture.width) * 4;\n      let grain = random(0, 30);\n      wallTexture.pixels[idx] = 0;\n      wallTexture.pixels[idx + 1] = 0;\n      wallTexture.pixels[idx + 2] = 0;\n      wallTexture.pixels[idx + 3] = grain; // Alpha noise\n    }\n  }\n  wallTexture.updatePixels();\n}\n\nfunction draw() {\n  // 1. Draw the \"Wall\" background (Projector light center)\n  background(240, 238, 230); // Off-white wall\n  \n  // Draw a vignette light center\n  noStroke();\n  for (let r = 800; r > 0; r -= 50) {\n    let inter = map(r, 0, 800, 0, 1);\n    let c = lerpColor(color(255, 255, 240), color(200, 190, 180), inter);\n    fill(c);\n    ellipse(width/2, height/2, r * 1.2, r * 1.0);\n  }\n\n  // 2. Physics Update\n  for (let i = 0; i < blobs.length; i++) {\n    blobs[i].update();\n    blobs[i].checkEdges();\n    blobs[i].interact(blobs);\n  }\n\n  // 3. Render Water (Ink) Layers first\n  // We use MULTIPLY blend mode to simulate transparent ink on a projector\n  blendMode(MULTIPLY);\n  for (let b of blobs) {\n    if (b.type === 'water') {\n      b.display();\n    }\n  }\n\n  // 4. Render Oil Layers\n  // Oil sits on top or repels, often blocking light or refracting differently\n  // We use BLEND or HARD_LIGHT for a thicker substance look\n  blendMode(BLEND);\n  for (let b of blobs) {\n    if (b.type === 'oil') {\n      b.display();\n    }\n  }\n\n  // Reset blend mode for UI and overlays\n  blendMode(BLEND);\n\n  // 5. Overlay Wall Texture (Grain)\n  image(wallTexture, 0, 0);\n\n  // 6. Heavy Vignette to simulate the dark room around the projection\n  drawVignette();\n\n  // 7. Instructions\n  if (instructionFade > 0) {\n    textAlign(CENTER);\n    textSize(16);\n    fill(50, instructionFade);\n    noStroke();\n    text(\"Click to drop Ink (Water)\", width / 2, height - 50);\n    text(\"Hold SHIFT + Click to drop Oil\", width / 2, height - 30);\n    instructionFade -= 1;\n  }\n  \n  // Auto-remove old blobs if too many\n  if (blobs.length > maxBlobs) {\n    blobs.splice(0, 1);\n  }\n}\n\nfunction mousePressed() {\n  let isOil = keyIsDown(SHIFT);\n  let sz = random(60, 120);\n  \n  let c;\n  if (isOil) {\n    // Dark, amber, or black oil\n    c = color(random(20, 50), random(10, 30), 0, 220);\n  } else {\n    // CMY Color model for mixing inks\n    let r = random(1);\n    if (r < 0.33) c = color(0, 180, 220); // Cyan\n    else if (r < 0.66) c = color(220, 0, 120); // Magenta\n    else c = color(220, 200, 0); // Yellow\n  }\n  \n  let type = isOil ? 'oil' : 'water';\n  blobs.push(new Blob(mouseX, mouseY, sz, c, type));\n}\n\nfunction drawVignette() {\n  push();\n  noFill();\n  strokeWeight(150);\n  stroke(20, 20, 20, 100);\n  rect(0, 0, width, height);\n  // Soften the inner edge of the stroke (fake gradient)\n  drawingContext.filter = 'blur(60px)';\n  stroke(10, 10, 10, 200);\n  rect(-50, -50, width+100, height+100);\n  drawingContext.filter = 'none';\n  pop();\n}\n\nclass Blob {\n  constructor(x, y, r, c, type) {\n    this.pos = createVector(x, y);\n    this.vel = p5.Vector.random2D().mult(random(0.2, 0.5));\n    this.r = r;\n    this.c = c; // Base color\n    this.type = type;\n    this.noiseOffset = random(1000);\n  }\n\n  update() {\n    // Add organic movement\n    let n = noise(this.pos.x * 0.005, this.pos.y * 0.005, frameCount * 0.01);\n    let noiseForce = p5.Vector.fromAngle(n * TWO_PI).mult(0.05);\n    this.vel.add(noiseForce);\n    \n    // Friction\n    this.vel.mult(0.98);\n    this.pos.add(this.vel);\n    \n    // Heat convection simulation (slow drift up or center)\n    // In projectors, heat sometimes makes fluid drift slowly\n    this.pos.y -= 0.02; \n  }\n\n  checkEdges() {\n    if (this.pos.x < -this.r) this.pos.x = width + this.r;\n    if (this.pos.x > width + this.r) this.pos.x = -this.r;\n    if (this.pos.y < -this.r) this.pos.y = height + this.r;\n    if (this.pos.y > height + this.r) this.pos.y = -this.r;\n  }\n\n  interact(others) {\n    for (let other of others) {\n      if (other !== this) {\n        let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);\n        \n        // Interaction radii logic\n        // Oil and Water repel strongly (hydrophobic)\n        // Water and Water clump loosely\n        // Oil and Oil clump tightly\n        \n        let minDist = (this.r + other.r) * 0.4; // Visual overlap allowed\n        \n        if (d < minDist) {\n          let force = p5.Vector.sub(this.pos, other.pos);\n          force.normalize();\n          \n          let magnitude = 0;\n          \n          if (this.type !== other.type) {\n            // Oil vs Water: Strong Repulsion\n            magnitude = 0.8; \n          } else if (this.type === 'oil') {\n             // Oil vs Oil: Surface tension tries to minimize boundary, \n             // but here we just keep them distinct circles that nudge\n             magnitude = 0.2;\n          } else {\n             // Water vs Water: They flow over each other easily\n             magnitude = 0.05;\n          }\n\n          // Apply force\n          force.mult(magnitude);\n          this.vel.add(force);\n        }\n      }\n    }\n  }\n\n  display() {\n    push();\n    translate(this.pos.x, this.pos.y);\n    \n    // Wobble effect\n    let wobble = sin(frameCount * 0.05 + this.noiseOffset) * (this.r * 0.05);\n    let w = this.r + wobble;\n    let h = this.r - wobble;\n    \n    tint(this.c);\n    imageMode(CENTER);\n    \n    // If it's oil, we make it look like a bubble/void\n    if (this.type === 'oil') {\n       // Draw a dark core\n       fill(this.c);\n       noStroke();\n       ellipse(0, 0, w*0.6, h*0.6);\n       // Draw the halo using the texture\n       image(blobTexture, 0, 0, w, h);\n       // Highlights for oil bubble surface\n       fill(255, 100);\n       ellipse(w*0.15, -h*0.15, w*0.1, h*0.1);\n    } else {\n       // Water/Ink is just the colored stain\n       image(blobTexture, 0, 0, w, h);\n    }\n    \n    pop();\n  }\n}",
      "totalTime": 57596,
      "createdAt": 1763648178379,
      "slug": "oil-water-8",
      "filename": "vibecheck_d8514bb3-12bb-454a-ab18-91a851df45f7_fc4384cd-4283-4899-9b2f-d83edc295aab.json"
    },
    {
      "projectId": "fc1851dd-416f-4b49-aabb-d05276599852",
      "outputId": "8a3a456d-05fb-4683-84f0-f7356383ea48",
      "prompt": "make something hypnotic",
      "mode": "glsl",
      "model": "flash",
      "srcCode": "precision mediump float;\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    uv.x *= u_resolution.x / u_resolution.y;\n\n    vec3 color = vec3(0.0);\n\n    float speed = 0.5;\n    float scale = 8.0;\n\n    vec2 p = uv * scale - vec2(scale/2.0);\n\n    float angle = atan(p.y, p.x);\n    float radius = length(p);\n\n    float spiral1 = sin(radius * 15.0 + angle * 5.0 + u_time * speed);\n    float spiral2 = cos(radius * 12.0 - angle * 7.0 + u_time * speed * 0.7);\n    float spiral3 = sin(radius * 10.0 + angle * 3.0 - u_time * speed * 0.9);\n\n    float pattern = spiral1 * 0.3 + spiral2 * 0.4 + spiral3 * 0.3;\n\n    float gradient_factor = 0.5 + 0.5 * sin(u_time * 0.3);\n\n    color.r = 0.5 + 0.5 * sin(pattern * 3.0 + u_time * 0.5 + gradient_factor);\n    color.g = 0.5 + 0.5 * sin(pattern * 2.5 + u_time * 0.7 + gradient_factor + 1.5);\n    color.b = 0.5 + 0.5 * sin(pattern * 3.5 + u_time * 0.9 + gradient_factor + 3.0);\n\n    color = mix(color, vec3(0.1, 0.05, 0.15), radius * 0.2); // Darken edges\n\n    gl_FragColor = vec4(color, 1.0);\n}",
      "totalTime": 3652,
      "createdAt": 1763648912733,
      "slug": "hypnotic",
      "filename": "vibecheck_fc1851dd-416f-4b49-aabb-d05276599852_8a3a456d-05fb-4683-84f0-f7356383ea48.json"
    },
    {
      "projectId": "menger-void-standalone",
      "outputId": "menger-void-00000000",
      "prompt": "Menger Void fractal",
      "mode": "glsl",
      "model": "manual",
      "srcCode": "precision highp float;\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n// The DNA: Menger Sponge SDF\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat map(vec3 p) {\n    // Spatial Repetition (The Recursive Loop)\n    p.z = mod(p.z, 4.0) - 2.0;\n    p.xy = mod(p.xy, 4.0) - 2.0;\n\n    float d = sdBox(p, vec3(1.0));\n    \n    // Fractal Iterations\n    float s = 1.0;\n    for(int m=0; m<3; m++) {\n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.0) / s;\n        d = max(d, c);\n    }\n    return d;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n    vec3 ro = vec3(0.0, 0.0, u_time * 2.0); // Camera movement\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    // Raymarching\n    float t = 0.0;\n    for(int i=0; i<64; i++) {\n        float d = map(ro + rd * t);\n        if(d < 0.001 || t > 20.0) break;\n        t += d;\n    }\n\n    vec3 p = ro + rd * t;\n    vec3 col = vec3(0.0);\n\n    if(t < 20.0) {\n        // Metallic Oil-Slick Coloring (Chromatic Aberration)\n        vec3 normal = normalize(vec3(\n            map(p + vec3(0.01, 0, 0)) - map(p - vec3(0.01, 0, 0)),\n            map(p + vec3(0, 0.01, 0)) - map(p - vec3(0, 0.01, 0)),\n            map(p + vec3(0, 0, 0.01)) - map(p - vec3(0, 0, 0.01))\n        ));\n        \n        float colorShift = sin(p.z * 0.5 + u_time);\n        col = 0.5 + 0.5 * cos(u_time + normal.xyy + vec3(0, 2, 4));\n        col *= exp(-0.2 * t); // Fog for fractal depth\n    }\n\n    gl_FragColor = vec4(col, 1.0);\n}",
      "totalTime": 0,
      "createdAt": 1768002297016,
      "slug": "menger-void",
      "filename": "Menger-Void.html"
    }
  ],
  "categories": {
    "glsl": [
      {
        "projectId": "018e2ce7-7a56-48f7-a3ca-3afd7332a0c6",
        "outputId": "2e714824-87cf-4fa2-9c7d-2a8bf15fe7d3",
        "prompt": "inside of lava lamp",
        "slug": "lava-lamp",
        "model": "threePro",
        "totalTime": 41131
      },
      {
        "projectId": "14d551de-462e-451a-8057-9f2eebb86ccf",
        "outputId": "c6bca154-dff3-4969-a17a-358e8940f0e3",
        "prompt": "metal cymatics",
        "slug": "metal-cymatics-1",
        "model": "threePro",
        "totalTime": 54789
      },
      {
        "projectId": "14d551de-462e-451a-8057-9f2eebb86ccf",
        "outputId": "d3e73387-863d-4538-8112-4e8f45780dec",
        "prompt": "metal cymatics",
        "slug": "metal-cymatics-2",
        "model": "threePro",
        "totalTime": 58959
      },
      {
        "projectId": "fc1851dd-416f-4b49-aabb-d05276599852",
        "outputId": "8a3a456d-05fb-4683-84f0-f7356383ea48",
        "prompt": "make something hypnotic",
        "slug": "hypnotic",
        "model": "flash",
        "totalTime": 3652
      },
      {
        "projectId": "menger-void-standalone",
        "outputId": "menger-void-00000000",
        "prompt": "Menger Void fractal",
        "slug": "menger-void",
        "model": "manual",
        "totalTime": 0
      }
    ],
    "overheadProjector": [
      {
        "projectId": "3ecb5102-b983-431b-8eda-6c38cca89771",
        "outputId": "018ab913-41cd-4697-9307-8708db078cb6",
        "prompt": "An interactive overhead projector",
        "slug": "overhead-projector-1",
        "model": "threePro",
        "totalTime": 58949
      },
      {
        "projectId": "3ecb5102-b983-431b-8eda-6c38cca89771",
        "outputId": "59396b46-e017-40ce-a3ed-c1a19e43e0f3",
        "prompt": "An interactive overhead projector",
        "slug": "overhead-projector-2",
        "model": "threePro",
        "totalTime": 56354
      },
      {
        "projectId": "3ecb5102-b983-431b-8eda-6c38cca89771",
        "outputId": "7b9d9692-a51a-46a6-9fc2-a3d0f6a87e98",
        "prompt": "An interactive overhead projector",
        "slug": "overhead-projector-3",
        "model": "threePro",
        "totalTime": 44559
      },
      {
        "projectId": "815c6d9b-4349-4ef2-99cc-a0dbabdb8944",
        "outputId": "1cb64249-42f6-474e-bf34-080dde3b3a9d",
        "prompt": "An overhead projector",
        "slug": "overhead-projector-4",
        "model": "threePro",
        "totalTime": 63399
      }
    ],
    "oilWater": [
      {
        "projectId": "b50978a9-95ad-41c1-b9ca-548722375915",
        "outputId": "1f38f7b7-117d-4b0c-8744-5489c2b71566",
        "prompt": "An interactive overhead projector with oil and water to mix on it",
        "slug": "oil-water-1",
        "model": "threePro",
        "totalTime": 49414
      },
      {
        "projectId": "b50978a9-95ad-41c1-b9ca-548722375915",
        "outputId": "7cfe70b3-e048-4d55-b187-bc475be4b4cd",
        "prompt": "An interactive overhead projector with oil and water to mix on it",
        "slug": "oil-water-2",
        "model": "threePro",
        "totalTime": 55171
      },
      {
        "projectId": "d8514bb3-12bb-454a-ab18-91a851df45f7",
        "outputId": "42fbb162-cc63-4c3e-812d-64a78b5a3cee",
        "prompt": "An interactive overhead projector where you drop oil and water in different colors and then it shines on the wall",
        "slug": "oil-water-3",
        "model": "threePro",
        "totalTime": 53272
      },
      {
        "projectId": "d8514bb3-12bb-454a-ab18-91a851df45f7",
        "outputId": "962624c9-f771-473b-8c7a-695a47a735bb",
        "prompt": "An interactive overhead projector where you drop oil and water in different colors and then it shines on the wall",
        "slug": "oil-water-4",
        "model": "threePro",
        "totalTime": 57821
      },
      {
        "projectId": "d8514bb3-12bb-454a-ab18-91a851df45f7",
        "outputId": "abd76830-facb-4535-b557-092886d4d943",
        "prompt": "An interactive overhead projector where you drop oil and water in different colors and then it shines on the wall",
        "slug": "oil-water-5",
        "model": "threePro",
        "totalTime": 40898
      },
      {
        "projectId": "d8514bb3-12bb-454a-ab18-91a851df45f7",
        "outputId": "ae318897-5d8e-4566-8b06-6bb2711b64b3",
        "prompt": "An interactive overhead projector where you drop oil and water in different colors and then it shines on the wall",
        "slug": "oil-water-6",
        "model": "threePro",
        "totalTime": 42500
      },
      {
        "projectId": "d8514bb3-12bb-454a-ab18-91a851df45f7",
        "outputId": "d1f09eb0-9042-45ba-b6ef-8a67249ec8df",
        "prompt": "An interactive overhead projector where you drop oil and water in different colors and then it shines on the wall",
        "slug": "oil-water-7",
        "model": "threePro",
        "totalTime": 48891
      },
      {
        "projectId": "d8514bb3-12bb-454a-ab18-91a851df45f7",
        "outputId": "fc4384cd-4283-4899-9b2f-d83edc295aab",
        "prompt": "An interactive overhead projector where you drop oil and water in different colors and then it shines on the wall",
        "slug": "oil-water-8",
        "model": "threePro",
        "totalTime": 57596
      }
    ]
  }
}