<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Deep Liquid Drops</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #050505;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      display: block;
      box-shadow: 0 0 50px rgba(0,0,0,0.8);
    }
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.3);
      font-family: sans-serif;
      font-size: 14px;
      pointer-events: none;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>
<body>

  <div id="instructions">
    Click & Hold to grow • Release to float • Spacebar to change colors
  </div>

  <script>
    let drops = [];
    let currentDrop = null;
    let mousePressStartTime = 0;
    const CLICK_THRESHOLD = 200;

    let grainImg;
    let palettes = [
      { name: "Deep Ocean", hues: [200, 220, 180, 240] },
      { name: "Midnight Purple", hues: [260, 280, 240, 290] },
      { name: "Ember", hues: [0, 20, 350, 40] },
      { name: "Forest", hues: [100, 140, 80, 160] }
    ];
    let currentPalette = 0;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(HSB, 360, 100, 100, 100);
      
      // Grain texture (slightly darker/subtler now)
      grainImg = createGraphics(width, height);
      grainImg.noStroke();
      for (let i = 0; i < 20000; i++) {
        grainImg.fill(0, 0, 100, 3); 
        grainImg.rect(random(width), random(height), 1, 1);
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      grainImg = createGraphics(width, height);
      grainImg.noStroke();
      for (let i = 0; i < 20000; i++) {
        grainImg.fill(0, 0, 100, 3);
        grainImg.rect(random(width), random(height), 1, 1);
      }
    }

    function draw() {
      // 1. Trail Management
      blendMode(BLEND);
      noStroke();
      // Darker background refresh to keep overall brightness down
      // Alpha is 15: creates a long trail but prevents total white-out
      fill(0, 0, 5, 15); 
      rect(0, 0, width, height);

      // Switch to ADD for blending lights
      blendMode(ADD);

      for (let i = drops.length - 1; i >= 0; i--) {
        let drop = drops[i];
        drop.update();
        drop.display();
        if (drop.isGone()) {
          drops.splice(i, 1);
        }
      }

      // Handle the growing drop
      if (mouseIsPressed && currentDrop) {
        let growAmount = (millis() - mousePressStartTime) * 0.05;
        currentDrop.r = 15 + growAmount;
        currentDrop.display(); 
      }

      // Texture Overlay
      blendMode(BLEND);
      image(grainImg, 0, 0);
    }

    class Drop {
      constructor(x, y, r, h) {
        this.pos = createVector(x, y);
        this.vel = createVector(0, 0);
        this.r = r;
        
        // Color Logic - CHILLED BRIGHTNESS
        this.hue = h + random(-20, 20);
        // Lower saturation (40-70) for a pastel/oily look
        this.sat = random(40, 70); 
        // Lower brightness (30-60) to prevent "neon" look
        this.bri = random(30, 60); 
        
        this.life = 255; 
        this.maxSpread = this.r * random(2, 4);
        
        this.noiseOffset = random(1000);
        this.shapeSpeed = random(0.01, 0.03); // Slower wobble
      }

      setInitialVelocity() {
        this.vel = p5.Vector.random2D().mult(random(0.2, 1.0));
      }

      update() {
        let wanderAngle = noise(this.pos.x * 0.003, this.pos.y * 0.003, frameCount * 0.005) * TWO_PI * 2;
        let wanderForce = p5.Vector.fromAngle(wanderAngle).mult(0.02);
        
        this.vel.add(wanderForce);
        this.vel.mult(0.99); 
        this.pos.add(this.vel);

        if (this.r < this.maxSpread) {
          this.r += 0.05; // Spreads slower
        }

        // LONGER LIFE: Decrement is very small now
        this.life -= 0.15; 

        // Wrap around
        if (this.pos.x < -this.r*3) this.pos.x = width + this.r*3;
        if (this.pos.x > width + this.r*3) this.pos.x = -this.r*3;
        if (this.pos.y < -this.r*3) this.pos.y = height + this.r*3;
        if (this.pos.y > height + this.r*3) this.pos.y = -this.r*3;
      }

      display(extraSize = 0) {
        noStroke();
        // Convert life to a 0-1 scale
        let lifeFactor = this.life / 255;
        
        push();
        translate(this.pos.x, this.pos.y);
        
        // SUBTLE LAYERS: 
        // Using very low alpha values (3, 5, 8, 15) to create a soft gradient
        
        // Layer 1: The Aura (Very large, very faint)
        fill(this.hue, this.sat, this.bri, 3 * lifeFactor);
        this.drawBlob(this.r * 2.5 + extraSize, 0);

        // Layer 2: The Soft Edge
        fill(this.hue, this.sat, this.bri, 5 * lifeFactor);
        this.drawBlob(this.r * 1.8 + extraSize, 10);

        // Layer 3: The Body
        fill(this.hue, this.sat, this.bri, 8 * lifeFactor);
        this.drawBlob(this.r * 1.2 + extraSize, 20);

        // Layer 4: The Core (Still transparent, but densest)
        fill(this.hue, this.sat, this.bri + 20, 15 * lifeFactor);
        this.drawBlob(this.r * 0.6 + extraSize, 30);
        
        pop();
      }

      drawBlob(radius, phaseOffset) {
        beginShape();
        // Smoother shape (step 0.1 instead of 0.2)
        for (let a = 0; a < TWO_PI; a += 0.1) {
          let xoff = cos(a) * 0.5 + 1 + this.noiseOffset;
          let yoff = sin(a) * 0.5 + 1 + this.noiseOffset;
          let n = noise(xoff, yoff, frameCount * this.shapeSpeed + phaseOffset);
          
          // Less aggressive wobble mapping for a "thicker" fluid feel
          let r = radius + map(n, 0, 1, -radius * 0.15, radius * 0.15);
          let x = r * cos(a);
          let y = r * sin(a);
          vertex(x, y);
        }
        endShape(CLOSE);
      }

      isGone() {
        return this.life <= 0;
      }
    }

    function mousePressed() {
      mousePressStartTime = millis();
      let pal = palettes[currentPalette].hues;
      let chosenHue = random(pal);
      currentDrop = new Drop(mouseX, mouseY, 10, chosenHue);
    }

    function mouseReleased() {
      if (currentDrop) {
        if (millis() - mousePressStartTime < CLICK_THRESHOLD) {
          currentDrop.r = random(20, 35);
          currentDrop.maxSpread = currentDrop.r * random(1.5, 2.5);
        }
        currentDrop.setInitialVelocity();
        drops.push(currentDrop);
        currentDrop = null;
      }
    }

    function keyPressed() {
      if (key === ' ') {
        currentPalette = (currentPalette + 1) % palettes.length;
      }
    }
  </script>
</body>
</html>