<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lava Lamp Projector</title>
    <style>
        :root {
            --frame-color: #2c2c2c;
            --screen-bg: #1a1a24; /* Darker, lava-lamp style bg */
            --bg-color: #111;
            --text-color: #777;
            --shadow-color: rgba(0, 0, 0, 0.6);
        }

        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'SF Mono', 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
        }

        .projector {
            width: 85vmin;
            aspect-ratio: 4 / 3;
            background-color: var(--frame-color);
            border: 1.5vmin solid #000;
            border-radius: 1vmin;
            box-shadow: 
                inset 0 0 4vmin rgba(0,0,0,0.8),
                0 0.5vmin 1vmin var(--shadow-color),
                0 1.5vmin 3vmin var(--shadow-color);
            padding: 3vmin;
            box-sizing: border-box;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .projector::before {
            content: '';
            position: absolute;
            top: 50%;
            left: -6vmin;
            transform: translateY(-50%);
            width: 4vmin;
            height: 4vmin;
            background: #444;
            border-radius: 50%;
            border: 0.5vmin solid #222;
            box-shadow: 0 0 1vmin rgba(0,0,0,0.5);
        }

        .screen {
            width: 100%;
            height: 100%;
            background-color: var(--screen-bg);
            box-shadow: inset 0 0 5vmin rgba(0,0,0,0.5);
            position: relative;
            overflow: hidden;
            cursor: pointer;
            border-radius: 0.5vmin;
            
            /* THE MAGIC: 
               High Blur = blobs merge from far away (the sucking effect).
               High Contrast = sharpens the blurred edges back into a solid shape. 
            */
            filter: blur(3.5vmin) contrast(40);
        }

        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* A warm glow in the center, dark edges */
            background-image: radial-gradient(circle at center, rgba(255,255,255,0.05) 0%, rgba(0,0,0,0.4) 100%);
            z-index: 10;
        }

        .blob {
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 50%;
            /* Screen or Lighten blend mode makes colors glow when they overlap */
            mix-blend-mode: screen; 
            will-change: transform;
            opacity: 0.9;
        }
        
        .title-bar {
            text-align: center;
        }
        
        h1 {
            font-size: 3vmin;
            margin: 0;
            font-weight: 500;
            letter-spacing: 0.2vmin;
            color: #888;
        }
        
        p {
            font-size: 1.8vmin;
            margin: 0.5vmin 0 0;
            opacity: 0.5;
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="projector">
            <div class="screen">
                <div class="vignette"></div>
                <!-- Blobs are created here by JavaScript -->
            </div>
        </div>
        <div class="title-bar">
            <h1>ðŸŒ‹ Lava Lamp Projector</h1>
            <p>Tap to add globs</p>
        </div>
    </div>

    <script>
        const screen = document.querySelector('.screen');
        
        let blobs = [];
        // Neon / Lava lamp colors
        const COLORS = ['#ff0055', '#7000ff', '#00ffaa', '#ffaa00'];
        const NUM_INITIAL_BLOBS = 7;
        // Increased min size so they don't disappear in the heavy blur
        const MIN_RADIUS = 6; 
        const MAX_RADIUS = 12; 
        const MAX_BLOBS = 30; 

        let bounds;
        let vminUnit;

        class Blob {
            constructor(x, y, rVmin, color) {
                this.x = x;
                this.y = y;
                this.rVmin = rVmin;
                this.rPx = 0;
                
                // DRAMATICALLY SLOWER SPEEDS
                // (Math.random() - 0.5) * 0.5 gives a range of -0.25 to 0.25
                this.vx = (Math.random() - 0.5) * 0.8;
                this.vy = (Math.random() - 0.5) * 0.8;

                this.el = document.createElement('div');
                this.el.classList.add('blob');
                this.el.style.background = color;
                
                this.updateSize();
                screen.appendChild(this.el);
            }

            updateSize() {
                this.rPx = this.rVmin * vminUnit;
                this.el.style.width = `${this.rPx * 2}px`;
                this.el.style.height = `${this.rPx * 2}px`;
            }

            update(dt) {
                const speedFactor = dt / 16;
                this.x += this.vx * speedFactor;
                this.y += this.vy * speedFactor;

                // Wall Collisions
                // We dampen velocity (-0.8) so they lose energy when hitting walls
                if (this.x - this.rPx < 0) {
                    this.x = this.rPx; 
                    this.vx *= -0.8; 
                }
                if (this.x + this.rPx > bounds.width) {
                    this.x = bounds.width - this.rPx;
                    this.vx *= -0.8;
                }
                if (this.y - this.rPx < 0) {
                    this.y = this.rPx;
                    this.vy *= -0.8;
                }
                if (this.y + this.rPx > bounds.height) {
                    this.y = bounds.height - this.rPx;
                    this.vy *= -0.8;
                }
            }

            draw() {
                this.el.style.transform = `translate3d(${this.x - this.rPx}px, ${this.y - this.rPx}px, 0)`;
            }
        }

        function handleCollisions() {
            for (let i = 0; i < blobs.length; i++) {
                for (let j = i + 1; j < blobs.length; j++) {
                    const blobA = blobs[i];
                    const blobB = blobs[j];

                    const dx = blobB.x - blobA.x;
                    const dy = blobB.y - blobA.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = blobA.rPx + blobB.rPx;

                    // If overlapping
                    if (distance < minDistance) {
                        const angle = Math.atan2(dy, dx);
                        const overlap = minDistance - distance;
                        
                        // SQUISHY PHYSICS:
                        // A very low force constant (0.005) means they don't bounce apart immediately.
                        // They are allowed to overlap deeply, which creates the "merged" look.
                        const force = overlap * 0.005; 

                        const forceX = Math.cos(angle) * force;
                        const forceY = Math.sin(angle) * force;
                        
                        // Mass-based reaction
                        const totalRadius = blobA.rPx + blobB.rPx;
                        const ratioA = blobB.rPx / totalRadius;
                        const ratioB = blobA.rPx / totalRadius;

                        blobA.vx -= forceX * ratioA;
                        blobA.vy -= forceY * ratioA;
                        blobB.vx += forceX * ratioB;
                        blobB.vy += forceY * ratioB;

                        // STICKINESS / FRICTION:
                        // When they touch, we average their speeds slightly to simulate thick liquid friction.
                        // This makes them "clump" and move together for a moment.
                        const friction = 0.005; 
                        const avgVx = (blobA.vx + blobB.vx) / 2;
                        const avgVy = (blobA.vy + blobB.vy) / 2;
                        
                        blobA.vx += (avgVx - blobA.vx) * friction;
                        blobA.vy += (avgVy - blobA.vy) * friction;
                        blobB.vx += (avgVx - blobB.vx) * friction;
                        blobB.vy += (avgVy - blobB.vy) * friction;
                    }
                }
            }
        }

        function createBlob(x, y) {
            if (blobs.length >= MAX_BLOBS) {
                const oldBlob = blobs.shift();
                oldBlob.el.remove();
            }

            const radiusVmin = MIN_RADIUS + Math.random() * (MAX_RADIUS - MIN_RADIUS);
            const color = COLORS[Math.floor(Math.random() * COLORS.length)];
            blobs.push(new Blob(x, y, radiusVmin, color));
        }
        
        function updateBounds() {
            bounds = screen.getBoundingClientRect();
            vminUnit = Math.min(window.innerWidth, window.innerHeight) / 100;
            
            blobs.forEach(blob => {
                if (bounds.width > 0 && bounds.height > 0) {
                     blob.x = Math.min(Math.max(blob.x, 0), bounds.width);
                     blob.y = Math.min(Math.max(blob.y, 0), bounds.height);
                }
                blob.updateSize();
            });
        }

        function init() {
            updateBounds();
            for (let i = 0; i < NUM_INITIAL_BLOBS; i++) {
                createBlob(
                    bounds.width / 2 + (Math.random() - 0.5) * 100,
                    bounds.height / 2 + (Math.random() - 0.5) * 100
                );
            }
        }
        
        screen.addEventListener('click', (e) => {
            const rect = screen.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            createBlob(x, y);
        });

        screen.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = screen.getBoundingClientRect();
            const x = e.touches[0].clientX - rect.left;
            const y = e.touches[0].clientY - rect.top;
            createBlob(x, y);
        }, { passive: false });
        
        let lastTime = performance.now();

        function animate(currentTime) {
            const dt = currentTime - lastTime;
            lastTime = currentTime;

            handleCollisions();

            blobs.forEach(blob => {
                blob.update(dt);
                blob.draw();
            });

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', updateBounds);

        init();
        requestAnimationFrame(animate);
    </script>
</body>
</html>