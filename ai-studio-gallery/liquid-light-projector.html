<!DOCTYPE html>
<html>
<head>
    <title>Liquid Light Projector</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050510;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        #container {
            position: relative;
            width: 90vmin;
            height: 65vmin;
            box-shadow: 0 0 80px rgba(20, 40, 100, 0.4);
            background: #000;
            border-radius: 12px;
            overflow: hidden;
        }
        #glcanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        #info {
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        #controls {
            align-self: flex-end;
            pointer-events: auto;
        }
        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }
        button:hover {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }
        button.active-water {
            background: rgba(0, 150, 255, 0.3);
            border-color: rgba(0, 150, 255, 0.6);
            color: #d0eaff;
        }
        button.active-oil {
            background: rgba(255, 50, 100, 0.3);
            border-color: rgba(255, 50, 100, 0.6);
            color: #ffd0d0;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="glcanvas"></canvas>
        <div id="ui-layer">
            <div id="controls">
                <button id="modeToggle">Mode: Oil</button>
            </div>
            <div id="info">
                Click to create â€¢ Hold to grow
            </div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl', { alpha: false });
    
    // --- State Management ---
    const state = {
        mode: 'oil', // 'oil' or 'water'
        damping: 0.985, // Physics damping
        cursorColor: [0,0,0]
    };

    const toggleBtn = document.getElementById('modeToggle');
    toggleBtn.classList.add('active-oil');

    toggleBtn.addEventListener('click', () => {
        if (state.mode === 'oil') {
            state.mode = 'water';
            state.damping = 0.995; // Water ripples last longer
            toggleBtn.textContent = "Mode: Water";
            toggleBtn.classList.remove('active-oil');
            toggleBtn.classList.add('active-water');
        } else {
            state.mode = 'oil';
            state.damping = 0.985; // Oil is thicker/more viscous
            toggleBtn.textContent = "Mode: Oil";
            toggleBtn.classList.remove('active-water');
            toggleBtn.classList.add('active-oil');
        }
    });

    if (!gl) alert('WebGL not supported!');

    // --- Shaders ---

    const vertexShaderSource = `
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    `;

    const simFragmentShaderSource = `
        precision highp float;
        uniform sampler2D u_state;
        uniform vec2 u_resolution;
        uniform vec3 u_color;
        uniform vec2 u_mouse;
        uniform float u_radius;
        uniform float u_isAdding;
        uniform float u_damping;
        uniform float u_isWaterMode; // 1.0 for Water, 0.0 for Oil

        void main() {
            vec2 texCoord = gl_FragCoord.xy / u_resolution;
            vec2 texel = 1.0 / u_resolution;

            vec4 self = texture2D(u_state, texCoord);
            vec4 n = texture2D(u_state, texCoord + vec2(0.0, texel.y));
            vec4 s = texture2D(u_state, texCoord - vec2(0.0, texel.y));
            vec4 e = texture2D(u_state, texCoord + vec2(texel.x, 0.0));
            vec4 w = texture2D(u_state, texCoord - vec2(texel.x, 0.0));
            
            // 1. Color Diffusion
            // If water mode, we slowly fade color out to clear
            vec3 avgColor = (n.rgb + s.rgb + e.rgb + w.rgb) * 0.25;
            vec3 diffusedColor = mix(self.rgb, avgColor, 0.1);
            
            if (u_isWaterMode > 0.5) {
                diffusedColor *= 0.98; // Fade color faster in water mode
            }

            // 2. Wave Propagation
            float laplacian = (n.a + s.a + e.a + w.a) - 4.0 * self.a;
            float newHeight = self.a + laplacian * 0.45;
            
            newHeight *= u_damping;
            
            vec4 newState = vec4(diffusedColor, newHeight);

            // --- Add Interaction ---
            if (u_isAdding > 0.5) {
                float dist = distance(gl_FragCoord.xy, u_mouse);
                if (dist < u_radius) {
                    float falloff = smoothstep(u_radius, 0.0, dist);
                    
                    // IF OIL: Add Color
                    if (u_isWaterMode < 0.5) {
                        newState.rgb = mix(newState.rgb, u_color, falloff * 0.6);
                        newState.rgb += u_color * falloff * 0.2; // Additive glow
                    }

                    // BOTH: Add Height (Ripples)
                    newState.a += falloff * 0.2; 
                }
            }
            
            gl_FragColor = newState;
        }
    `;

    const renderFragmentShaderSource = `
        precision highp float;
        uniform sampler2D u_state;
        uniform vec2 u_resolution;
        uniform float u_isWaterMode;

        void main() {
            vec2 texCoord = gl_FragCoord.xy / u_resolution;
            vec2 texel = 1.0 / u_resolution;

            // Height & Normals
            float h = texture2D(u_state, texCoord).a;
            float h_e = texture2D(u_state, texCoord + vec2(texel.x, 0.0)).a;
            float h_w = texture2D(u_state, texCoord - vec2(texel.x, 0.0)).a;
            float h_n = texture2D(u_state, texCoord + vec2(0.0, texel.y)).a;
            float h_s = texture2D(u_state, texCoord - vec2(0.0, texel.y)).a;

            vec3 normal = normalize(vec3(h_w - h_e, h_s - h_n, 0.2));

            // Refraction
            // Water refracts more cleanly/sharply
            float refractStrength = (u_isWaterMode > 0.5) ? 0.06 : 0.03;
            vec2 refractCoord = texCoord + normal.xy * refractStrength;
            
            vec4 data = texture2D(u_state, refractCoord);
            vec3 texColor = data.rgb;

            // Lighting
            vec3 lightDir = normalize(vec3(0.5, 0.7, 1.0));
            float diffuse = max(0.0, dot(normal, lightDir));
            // Sharper specular for water, softer for oil
            float specPower = (u_isWaterMode > 0.5) ? 64.0 : 32.0;
            float specular = pow(max(0.0, dot(normal, lightDir)), specPower);

            // --- Mode Compositing ---
            vec3 finalColor;

            if (u_isWaterMode > 0.5) {
                // WATER MODE: Blue tint + Refraction + High Specular
                vec3 waterBase = vec3(0.0, 0.05, 0.15); // Deep blue
                finalColor = waterBase;
                finalColor += specular * 0.9; // Shiny surface
                finalColor += diffuse * 0.2;
                // Add a little bit of the underlying texture if it exists (fading out)
                finalColor += texColor * 0.5; 
            } else {
                // OIL MODE: Vibrant Color Map + Soft Glow
                vec3 oilBase = vec3(0.05, 0.05, 0.08);
                finalColor = oilBase + (texColor * 1.8); // Boost brightness
                finalColor += diffuse * 0.3;
                finalColor += specular * 0.6;
            }

            gl_FragColor = vec4(finalColor, 1.0);
        }
    `;

    // --- WebGL Boilerplate ---

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
        const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
            return null;
        }
        return program;
    }

    gl.getExtension('OES_texture_float');
    gl.getExtension('OES_texture_float_linear');

    const simProgram = createProgram(gl, vertexShaderSource, simFragmentShaderSource);
    const renderProgram = createProgram(gl, vertexShaderSource, renderFragmentShaderSource);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

    function createFramebuffer(w, h) {
        const fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.FLOAT, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
        return { fb, tex };
    }

    let width, height;
    let framebuffers = [];

    function resize() {
        const dpr = window.devicePixelRatio || 1;
        const displayWidth = Math.floor(gl.canvas.clientWidth * dpr);
        const displayHeight = Math.floor(gl.canvas.clientHeight * dpr);

        if (gl.canvas.width !== displayWidth || gl.canvas.height !== displayHeight) {
            gl.canvas.width = displayWidth;
            gl.canvas.height = displayHeight;
            width = displayWidth;
            height = displayHeight;
            framebuffers = [createFramebuffer(width, height), createFramebuffer(width, height)];
        }
    }
    resize();
    window.addEventListener('resize', resize);
    
    // --- Interaction ---
    const mouse = { isDown: false, pos: [0, 0], radius: 0 };

    function updateMousePosition(e) {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        mouse.pos = [
            (e.clientX - rect.left) * dpr, 
            (rect.height - (e.clientY - rect.top)) * dpr
        ];
    }

    canvas.addEventListener('mousedown', (e) => {
        updateMousePosition(e);
        mouse.isDown = true;
        mouse.radius = 10;
        state.cursorColor = hslToRgb(Math.random(), 0.9, 0.7); 
    });
    canvas.addEventListener('mouseup', () => mouse.isDown = false);
    canvas.addEventListener('mousemove', (e) => { if (mouse.isDown) updateMousePosition(e); });
    canvas.addEventListener('mouseleave', () => mouse.isDown = false);

    // --- Loop ---
    let readFB = framebuffers[0];
    let writeFB = framebuffers[1];

    function animate() {
        const isWaterVal = state.mode === 'water' ? 1.0 : 0.0;

        // 1. Sim Pass
        gl.useProgram(simProgram);
        gl.bindFramebuffer(gl.FRAMEBUFFER, writeFB.fb);
        gl.viewport(0, 0, width, height);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, readFB.tex);
        gl.uniform1i(gl.getUniformLocation(simProgram, "u_state"), 0);

        const posLocSim = gl.getAttribLocation(simProgram, "a_position");
        gl.enableVertexAttribArray(posLocSim);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(posLocSim, 2, gl.FLOAT, false, 0, 0);

        gl.uniform2f(gl.getUniformLocation(simProgram, "u_resolution"), width, height);
        gl.uniform1f(gl.getUniformLocation(simProgram, "u_damping"), state.damping);
        gl.uniform1f(gl.getUniformLocation(simProgram, "u_isWaterMode"), isWaterVal);
        
        if (mouse.isDown) {
            mouse.radius = Math.min(width * 0.15, mouse.radius + 2.0);
            gl.uniform1f(gl.getUniformLocation(simProgram, "u_isAdding"), 1.0);
            gl.uniform2fv(gl.getUniformLocation(simProgram, "u_mouse"), mouse.pos);
            gl.uniform1f(gl.getUniformLocation(simProgram, "u_radius"), mouse.radius);
            gl.uniform3fv(gl.getUniformLocation(simProgram, "u_color"), state.cursorColor);
        } else {
            gl.uniform1f(gl.getUniformLocation(simProgram, "u_isAdding"), 0.0);
        }
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        // 2. Render Pass
        gl.useProgram(renderProgram);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, width, height);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, writeFB.tex);
        gl.uniform1i(gl.getUniformLocation(renderProgram, "u_state"), 0);
        gl.uniform1f(gl.getUniformLocation(renderProgram, "u_isWaterMode"), isWaterVal);
        
        const posLocRender = gl.getAttribLocation(renderProgram, "a_position");
        gl.enableVertexAttribArray(posLocRender);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(posLocRender, 2, gl.FLOAT, false, 0, 0);

        gl.uniform2f(gl.getUniformLocation(renderProgram, "u_resolution"), width, height);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        [readFB, writeFB] = [writeFB, readFB];
        requestAnimationFrame(animate);
    }
    animate();

    function hslToRgb(h, s, l){
        let r, g, b;
        if(s == 0){
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if(t < 0) t += 1;
                if(t > 1) t -= 1;
                if(t < 1/6) return p + (q - p) * 6 * t;
                if(t < 1/2) return q;
                if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            }
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }
        return [r, g, b];
    }
</script>
</body>
</html>