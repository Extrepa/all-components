<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sentient Shard Swarm</title>
    <style>
        :root {
            --bg-color: #050508;
            --shard-color-1: #00f2ff;
            --shard-color-2: #ff0055;
            --text-color: #ffffff;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #container {
            width: 100%;
            max-width: 800px;
            aspect-ratio: 4/3;
            position: relative;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
            box-shadow: 0 0 50px rgba(0, 242, 255, 0.1);
            overflow: hidden;
            border-radius: 8px;
            cursor: none; /* Hide default cursor */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            opacity: 0.7;
            transition: opacity 0.5s;
        }

        h1 {
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.5);
            margin: 0;
        }

        p {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.3);
            margin-top: 5px;
        }
    </style>
</head>
<body>

    <div id="container">
        <div id="ui-layer">
            <h1>Subject: Geom-7</h1>
            <p>Move to attract â€¢ Click to change mood</p>
        </div>
        <canvas id="canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('container');

        let width, height;
        let particles = [];
        const numParticles = 400;
        
        // Mouse state
        const mouse = { x: 0, y: 0, prevX: 0, prevY: 0, vX: 0, vY: 0 };
        let isAngry = false;
        
        // Configuration
        const config = {
            eyeRadius: 30,
            eyeOffsetX: 50,
            eyeOffsetY: -20,
            mouthWidth: 100,
            mouthOffsetY: 50,
            swarmLoose: 0.05, // Easing factor
            swarmTight: 0.1,
            jitter: 2
        };

        // Resize handling
        function resize() {
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            width = canvas.width;
            height = canvas.height;
        }
        window.addEventListener('resize', resize);
        resize();

        // Initial mouse position center
        mouse.x = width / 2;
        mouse.y = height / 2;

        // Interaction
        container.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        container.addEventListener('mousedown', () => {
            isAngry = !isAngry;
            // Impulse explosion on click
            particles.forEach(p => {
                p.vx += (Math.random() - 0.5) * 20;
                p.vy += (Math.random() - 0.5) * 20;
            });
        });

        // Particle Class
        class Shard {
            constructor(index) {
                this.index = index;
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.vx = 0;
                this.vy = 0;
                this.size = Math.random() * 6 + 2;
                this.color = this.getColor();
                this.angle = Math.random() * Math.PI * 2;
                this.spin = (Math.random() - 0.5) * 0.2;
                
                // Assign role based on index
                if (index < 60) this.role = 'eyeLeft';
                else if (index < 120) this.role = 'eyeRight';
                else if (index < 220) this.role = 'mouth';
                else this.role = 'cloud';
            }

            getColor() {
                const hue = isAngry ? Math.random() * 40 + 340 : Math.random() * 60 + 160; // Red/Pink vs Cyan/Blue
                const sat = 80;
                const light = 60;
                return `hsl(${hue}, ${sat}%, ${light}%)`;
            }

            update() {
                // Calculate target position based on role
                let tx, ty;
                
                // Base offset from mouse (swarming effect)
                const time = Date.now() * 0.002;
                
                if (this.role === 'eyeLeft') {
                    // Left Eye Cluster
                    tx = mouse.x - config.eyeOffsetX;
                    ty = mouse.y + config.eyeOffsetY;
                    // Orbit/Jitter
                    tx += Math.cos(time + this.index) * 10;
                    ty += Math.sin(time + this.index) * 10;
                } else if (this.role === 'eyeRight') {
                    // Right Eye Cluster
                    tx = mouse.x + config.eyeOffsetX;
                    ty = mouse.y + config.eyeOffsetY;
                    tx += Math.cos(time + this.index) * 10;
                    ty += Math.sin(time + this.index) * 10;
                } else if (this.role === 'mouth') {
                    // Mouth Curve
                    // Map index to x position along mouth width
                    const mouthIndex = this.index - 120;
                    const totalMouth = 100;
                    const norm = mouthIndex / totalMouth; // 0 to 1
                    const xOffset = (norm - 0.5) * config.mouthWidth;
                    
                    tx = mouse.x + xOffset;
                    
                    // Parabola for smile/frown
                    // y = x^2
                    const curveStrength = isAngry ? -40 : 40; // Negative for frown, Positive for smile
                    const curveY = ((xOffset / (config.mouthWidth/2)) ** 2) * (isAngry ? 20 : 15);
                    
                    // Determine concavity direction
                    const direction = isAngry ? 1 : 1; 
                    
                    // Calculate curvature
                    // For a smile: ends are higher than center.
                    // For a frown: ends are lower than center.
                    
                    let yOffset = 0;
                    if (isAngry) {
                         // Frown: center higher, sides lower
                         yOffset = -(1 - Math.pow(Math.abs(norm - 0.5) * 2, 2)) * 20;
                    } else {
                        // Smile: center lower, sides higher
                        yOffset = (Math.pow(Math.abs(norm - 0.5) * 2, 2)) * 20;
                    }

                    ty = mouse.y + config.mouthOffsetY + yOffset;
                    
                    // Add some buzz
                    tx += (Math.random() - 0.5) * 3;
                    ty += (Math.random() - 0.5) * 3;

                } else {
                    // Cloud / Aura
                    // Orbit randomly around the mouse
                    const angle = this.index * 0.1 + time * 0.5;
                    const radius = 80 + Math.random() * 100;
                    tx = mouse.x + Math.cos(angle) * radius;
                    ty = mouse.y + Math.sin(angle) * radius;
                }

                // Mouse velocity influence (lag behind)
                tx -= mouse.vX * 5;
                ty -= mouse.vY * 5;

                // Physics
                const dx = tx - this.x;
                const dy = ty - this.y;
                
                // Spring force
                const dist = Math.sqrt(dx*dx + dy*dy);
                const force = isAngry ? 0.08 : 0.04;
                
                this.vx += dx * force * 0.5;
                this.vy += dy * force * 0.5;

                // Damping (Friction)
                this.vx *= 0.85;
                this.vy *= 0.85;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Rotation
                this.angle += this.spin + (Math.abs(this.vx) + Math.abs(this.vy)) * 0.02;

                // Dynamic Color update
                if (Math.random() < 0.05) this.color = this.getColor();
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.8;
                
                // Draw Geometric Shard (Triangle)
                ctx.beginPath();
                ctx.moveTo(0, -this.size);
                ctx.lineTo(this.size, this.size);
                ctx.lineTo(-this.size, this.size);
                ctx.closePath();
                ctx.fill();

                // Glow effect occasionally
                if (Math.random() < 0.1) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        function init() {
            particles = [];
            for (let i = 0; i < numParticles; i++) {
                particles.push(new Shard(i));
            }
        }

        function animate() {
            // Background trail
            ctx.fillStyle = 'rgba(5, 5, 8, 0.3)';
            ctx.fillRect(0, 0, width, height);

            // Calculate mouse velocity
            mouse.vX = mouse.x - mouse.prevX;
            mouse.vY = mouse.y - mouse.prevY;
            mouse.prevX = mouse.x;
            mouse.prevY = mouse.y;

            ctx.globalCompositeOperation = 'lighter'; // Additive blending for glowing look

            particles.forEach(p => {
                p.update();
                p.draw();
            });

            ctx.globalCompositeOperation = 'source-over';

            // Connect some lines between nearby particles for "shard/web" look
            connectParticles();

            requestAnimationFrame(animate);
        }

        function connectParticles() {
            ctx.strokeStyle = isAngry ? 'rgba(255, 0, 80, 0.15)' : 'rgba(0, 242, 255, 0.15)';
            ctx.lineWidth = 1;
            
            // Only connect a subset to save performance
            for (let i = 0; i < particles.length; i += 4) {
                const p1 = particles[i];
                // Check neighbors
                for (let j = i + 1; j < particles.length; j += 10) {
                    const p2 = particles[j];
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const dist = dx*dx + dy*dy;
                    
                    if (dist < 1600) { // < 40px distance
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }
            }
        }

        init();
        animate();

    </script>
</body>
</html>