<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Organic Light Drops</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden; /* Prevent scrollbars */
      background-color: #050505;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      display: block;
      box-shadow: 0 0 50px rgba(0,0,0,0.5);
    }
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.4);
      font-family: sans-serif;
      font-size: 14px;
      pointer-events: none; /* Let clicks pass through to canvas */
    }
  </style>
  <!-- Load p5.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>
<body>

  <div id="instructions">
    Click & Hold to grow • Release to float • Spacebar to change colors
  </div>

  <script>
    let drops = [];
    let currentDrop = null;
    let mousePressStartTime = 0;
    const CLICK_THRESHOLD = 200;

    // Textures and Palettes
    let grainImg;
    let palettes = [
      { name: "Neon", hues: [280, 320, 190, 220] },  // Purples and Cyans
      { name: "Fire", hues: [0, 30, 50, 340] },      // Reds and Oranges
      { name: "Toxic", hues: [90, 130, 160, 60] },   // Greens and Teals
      { name: "White", hues: [0, 0, 0, 0] }          // Pure light
    ];
    let currentPalette = 0;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(HSB, 360, 100, 100, 100);
      
      // Pre-generate a grain texture for better performance
      grainImg = createGraphics(width, height);
      grainImg.noStroke();
      for (let i = 0; i < 20000; i++) {
        grainImg.fill(0, 0, 100, 5); // White low opacity
        grainImg.rect(random(width), random(height), 1, 1);
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      // Re-generate grain on resize
      grainImg = createGraphics(width, height);
      grainImg.noStroke();
      for (let i = 0; i < 20000; i++) {
        grainImg.fill(0, 0, 100, 5);
        grainImg.rect(random(width), random(height), 1, 1);
      }
    }

    function draw() {
      // 1. Trail Management
      // Switch to BLEND to draw a semi-transparent background
      blendMode(BLEND);
      noStroke();
      fill(230, 40, 5, 20); // Dark purple-ish background
      rect(0, 0, width, height);

      // Switch to ADD for glowing light effects
      blendMode(ADD);

      for (let i = drops.length - 1; i >= 0; i--) {
        let drop = drops[i];
        drop.update();
        drop.display();
        if (drop.isGone()) {
          drops.splice(i, 1);
        }
      }

      // Handle the active "growing" drop
      if (mouseIsPressed && currentDrop) {
        let growAmount = (millis() - mousePressStartTime) * 0.05;
        currentDrop.r = 15 + growAmount;
        
        // Add a slight "pulse" effect while holding
        let pulse = sin(frameCount * 0.5) * 2;
        currentDrop.display(pulse); 
      }

      // 2. Texture Overlay
      blendMode(BLEND);
      image(grainImg, 0, 0);
    }

    class Drop {
      constructor(x, y, r, h) {
        this.pos = createVector(x, y);
        this.vel = createVector(0, 0);
        this.r = r;
        
        // Color logic
        if (palettes[currentPalette].name === "White") {
           this.hue = 0;
           this.sat = 0;
           this.bri = 100;
        } else {
           this.hue = h + random(-15, 15);
           this.sat = random(70, 100);
           this.bri = random(80, 100);
        }
        
        this.life = 255; 
        this.maxSpread = this.r * random(2, 5);
        
        // Organic Shape Noise
        this.noiseOffset = random(1000);
        this.shapeSpeed = random(0.02, 0.05);
      }

      setInitialVelocity() {
        this.vel = p5.Vector.random2D().mult(random(0.5, 2));
      }

      update() {
        // Wandering force
        let wanderAngle = noise(this.pos.x * 0.005, this.pos.y * 0.005, frameCount * 0.01) * TWO_PI * 2;
        let wanderForce = p5.Vector.fromAngle(wanderAngle).mult(0.05);
        
        this.vel.add(wanderForce);
        this.vel.mult(0.98); // Friction
        this.pos.add(this.vel);

        // Spread logic
        if (this.r < this.maxSpread) {
          this.r += 0.2;
        }

        this.life -= 1.0; // Fade speed

        // Wrap around screen
        if (this.pos.x < -this.r*2) this.pos.x = width + this.r*2;
        if (this.pos.x > width + this.r*2) this.pos.x = -this.r*2;
        if (this.pos.y < -this.r*2) this.pos.y = height + this.r*2;
        if (this.pos.y > height + this.r*2) this.pos.y = -this.r*2;
      }

      display(extraSize = 0) {
        noStroke();
        let currentAlpha = (this.life / 255) * 100;
        
        push();
        translate(this.pos.x, this.pos.y);
        
        // Outer glow
        fill(this.hue, this.sat, this.bri, currentAlpha * 0.1);
        this.drawBlob(this.r + extraSize + 20, 0);

        // Mid glow
        fill(this.hue, this.sat, this.bri, currentAlpha * 0.2);
        this.drawBlob((this.r + extraSize) * 0.8, 50);

        // Core
        fill(this.hue, this.sat - 20, 100, currentAlpha * 0.6);
        this.drawBlob((this.r + extraSize) * 0.4, 100);
        
        pop();
      }

      drawBlob(radius, phaseOffset) {
        beginShape();
        for (let a = 0; a < TWO_PI; a += 0.2) {
          let xoff = cos(a) + 1 + this.noiseOffset;
          let yoff = sin(a) + 1 + this.noiseOffset;
          // Calculate noise
          let n = noise(xoff, yoff, frameCount * this.shapeSpeed + phaseOffset);
          // Map noise to radius fluctuation
          let r = radius + map(n, 0, 1, -radius * 0.2, radius * 0.2);
          let x = r * cos(a);
          let y = r * sin(a);
          vertex(x, y);
        }
        endShape(CLOSE);
      }

      isGone() {
        return this.life <= 0;
      }
    }

    function mousePressed() {
      mousePressStartTime = millis();
      
      let pal = palettes[currentPalette].hues;
      let chosenHue = random(pal);
      
      currentDrop = new Drop(mouseX, mouseY, 10, chosenHue);
    }

    function mouseReleased() {
      if (currentDrop) {
        if (millis() - mousePressStartTime < CLICK_THRESHOLD) {
          currentDrop.r = random(20, 40);
          currentDrop.maxSpread = currentDrop.r * random(1.5, 3);
        }
        currentDrop.setInitialVelocity();
        drops.push(currentDrop);
        currentDrop = null;
      }
    }

    function keyPressed() {
      if (key === ' ') {
        currentPalette = (currentPalette + 1) % palettes.length;
      }
    }
  </script>
</body>
</html>