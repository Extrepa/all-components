<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus: Chromatic Flow Field</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #010103; cursor: none; }
        canvas { display: block; }
        .nexus-label {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            font-family: 'Courier New', monospace;
            letter-spacing: 0.5rem;
            color: rgba(0, 255, 255, 0.5);
            text-transform: uppercase;
            font-size: 0.7rem;
            text-align: center;
        }
    </style>
</head>
<body>

    <div class="nexus-label">
        <div class="tracking-[1rem] mb-2">Fluidic Entropy</div>
        <div class="opacity-30">Bilateral Symmetry Engaged</div>
    </div>
    <canvas id="flowCanvas"></canvas>

<script>
/**
 * NEXUS LOGIC: FLOW FIELD
 * GUIDED BY NOISE, RENDERED IN RGB TRACERS
 */

const canvas = document.getElementById('flowCanvas');
const ctx = canvas.getContext('2d');

let width, height;
let particles = [];
let noiseGrid = [];
const particleCount = 4000;
const cellSize = 20;
let zOff = 0; // The 3rd dimension of noise (Time)

class Particle {
    constructor() {
        this.reset();
    }

    reset() {
        this.x = Math.random() * (width / 2); // Start on left half for symmetry
        this.y = Math.random() * height;
        this.prevX = this.x;
        this.prevY = this.y;
        this.vel = { x: 0, y: 0 };
        this.acc = { x: 0, y: 0 };
        this.maxSpeed = Math.random() * 2 + 1;
        this.hue = Math.random() * 60 + 180; // Start in Cyan/Blue range
    }

    update(angle) {
        this.prevX = this.x;
        this.prevY = this.y;

        this.acc.x = Math.cos(angle) * 0.2;
        this.acc.y = Math.sin(angle) * 0.2;

        this.vel.x += this.acc.x;
        this.vel.y += this.acc.y;

        // Limit speed
        const mag = Math.sqrt(this.vel.x**2 + this.vel.y**2);
        if (mag > this.maxSpeed) {
            this.vel.x = (this.vel.x / mag) * this.maxSpeed;
            this.vel.y = (this.vel.y / mag) * this.maxSpeed;
        }

        this.x += this.vel.x;
        this.y += this.vel.y;

        // Wrap around boundaries
        if (this.x < 0 || this.x > width / 2 || this.y < 0 || this.y > height) {
            this.reset();
        }

        this.hue = (this.hue + 0.5) % 360;
    }

    draw() {
        const opacity = 0.15;
        ctx.lineWidth = 1;
        
        // Draw Original (Left Side)
        ctx.strokeStyle = `hsla(${this.hue}, 100%, 50%, ${opacity})`;
        ctx.beginPath();
        ctx.moveTo(this.prevX, this.prevY);
        ctx.lineTo(this.x, this.y);
        ctx.stroke();

        // Draw Mirror (Right Side)
        ctx.strokeStyle = `hsla(${(this.hue + 120) % 360}, 100%, 50%, ${opacity})`;
        ctx.beginPath();
        ctx.moveTo(width - this.prevX, this.prevY);
        ctx.lineTo(width - this.x, this.y);
        ctx.stroke();
    }
}

// Simple Noise Implementation (Sine-based pseudo-randomness for flow)
function getNoise(x, y, z) {
    return (Math.sin(x * 0.01) + Math.cos(y * 0.01) + Math.sin(z)) * Math.PI * 2;
}

function init() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    particles = [];
    for (let i = 0; i < particleCount; i++) {
        particles.push(new Particle());
    }
    // Fade the background initially
    ctx.fillStyle = '#010103';
    ctx.fillRect(0, 0, width, height);
}

function animate() {
    // We don't clear the frame fully, creating the "tracer" trail effect
    ctx.fillStyle = 'rgba(1, 1, 3, 0.02)';
    ctx.fillRect(0, 0, width, height);

    zOff += 0.005;

    particles.forEach(p => {
        const angle = getNoise(p.x, p.y, zOff);
        p.update(angle);
        p.draw();
    });

    requestAnimationFrame(animate);
}

window.addEventListener('resize', init);
init();
animate();

// Interactive entropy: Mouse affects the noise
window.addEventListener('mousemove', (e) => {
    zOff += 0.01;
});

</script>
</body>
</html>
