<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Psychedelic Vision</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.run/three",
            "three/addons/": "https://esm.run/three/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // 1. Scene, Camera, Renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // 2. Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.03;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.2;

        // 3. Lights
        const pointLight1 = new THREE.PointLight(0xff00ff, 200);
        scene.add(pointLight1);
        const pointLight2 = new THREE.PointLight(0x00ffff, 200);
        scene.add(pointLight2);
        const pointLight3 = new THREE.PointLight(0xffff00, 200);
        scene.add(pointLight3);

        // 4. Psychedelic Elements

        // 4.1. The Warping Background
        const bgGeometry = new THREE.IcosahedronGeometry(300, 20);
        const bgMaterial = new THREE.MeshBasicMaterial({
            color: 0x0000ff,
            wireframe: true,
            side: THREE.BackSide,
            fog: false
        });
        const backgroundSphere = new THREE.Mesh(bgGeometry, bgMaterial);
        const originalBgPositions = bgGeometry.attributes.position.clone();
        scene.add(backgroundSphere);

        // 4.2. The Rainbow Tunnel
        const tunnelGroup = new THREE.Group();
        const tunnelRingCount = 60;
        const ringGeometry = new THREE.TorusGeometry(15, 0.3, 16, 100);
        
        for (let i = 0; i < tunnelRingCount; i++) {
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.2,
                metalness: 0.9,
                emissive: 0x000000,
            });
            const ring = new THREE.Mesh(ringGeometry, material);
            ring.position.z = (i / tunnelRingCount) * -300;
            tunnelGroup.add(ring);
        }
        scene.add(tunnelGroup);

        // 4.3. The Central "God-Object"
        const coreGroup = new THREE.Group();
        const coreGeometry = new THREE.TorusKnotGeometry(4, 1.2, 300, 20, 3, 5);
        const coreMaterial = new THREE.MeshPhysicalMaterial({
            metalness: 0.9,
            roughness: 0.05,
            transmission: 1.0,
            thickness: 1.5,
            ior: 2.33,
            reflectivity: 1.0,
        });
        const coreObject = new THREE.Mesh(coreGeometry, coreMaterial);
        coreGroup.add(coreObject);

        const coreWireframe = new THREE.Mesh(
            coreGeometry,
            new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.1 })
        );
        coreWireframe.scale.set(1.001, 1.001, 1.001);
        coreGroup.add(coreWireframe);
        scene.add(coreGroup);

        // 4.4. The Cosmic Particle Dust
        const particleCount = 30000;
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const particleVector = new THREE.Vector3();

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const phi = Math.acos(2 * Math.random() - 1);
            const theta = Math.random() * Math.PI * 2;
            const radius = 10 + Math.random() * 80;
            particleVector.setFromSphericalCoords(radius, phi, theta);
            positions[i3] = particleVector.x;
            positions[i3 + 1] = particleVector.y;
            positions[i3 + 2] = particleVector.z;

            const color = new THREE.Color();
            color.setHSL(Math.random(), 1.0, 0.5);
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.25,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false,
            sizeAttenuation: true
        });
        
        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);

        // 5. Animation Loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            const hue = (elapsedTime * 0.05) % 1;

            // Animate lights
            pointLight1.position.x = Math.sin(elapsedTime * 0.7) * 15;
            pointLight1.position.y = Math.cos(elapsedTime * 0.5) * 15;
            pointLight1.position.z = Math.cos(elapsedTime * 0.3) * 15;
            pointLight1.color.setHSL(hue, 1, 0.5);

            pointLight2.position.x = Math.cos(elapsedTime * 0.3) * 15;
            pointLight2.position.y = Math.sin(elapsedTime * 0.5) * 15;
            pointLight2.position.z = Math.sin(elapsedTime * 0.7) * 15;
            pointLight2.color.setHSL((hue + 0.33) % 1, 1, 0.5);
            
            pointLight3.position.x = Math.sin(elapsedTime * 0.4) * 15;
            pointLight3.position.y = Math.cos(elapsedTime * 0.6) * 15;
            pointLight3.position.z = Math.cos(elapsedTime * 0.8) * 15;
            pointLight3.color.setHSL((hue + 0.66) % 1, 1, 0.5);

            // Animate core object
            coreGroup.rotation.x = elapsedTime * 0.2;
            coreGroup.rotation.y = elapsedTime * 0.15;
            const scale = 1 + Math.sin(elapsedTime * 2) * 0.05;
            coreGroup.scale.set(scale, scale, scale);
            coreMaterial.color.setHSL(hue, 0.8, 0.6);

            // Animate tunnel
            tunnelGroup.position.z += 0.5;
            if (tunnelGroup.position.z > 300 / tunnelRingCount) {
                tunnelGroup.position.z = 0;
            }
            tunnelGroup.children.forEach((ring, index) => {
                const ringHue = (hue + (index / tunnelRingCount) * 0.4) % 1;
                ring.material.color.setHSL(ringHue, 1, 0.5);
                ring.material.emissive.setHSL(ringHue, 1, 0.2);
                ring.rotation.z = elapsedTime * 0.5;
            });
            
            // Animate background
            const bgPos = backgroundSphere.geometry.attributes.position;
            const time = elapsedTime * 0.5;
            for (let i = 0; i < bgPos.count; i++) {
                const x = originalBgPositions.getX(i);
                const y = originalBgPositions.getY(i);
                const z = originalBgPositions.getZ(i);
                const displacement = (Math.sin(x * 0.02 + time) + Math.cos(y * 0.02 + time) + Math.sin(z * 0.02 + time)) * 10;
                particleVector.fromBufferAttribute(originalBgPositions, i).normalize().multiplyScalar(300 + displacement);
                bgPos.setXYZ(i, particleVector.x, particleVector.y, particleVector.z);
            }
            bgPos.needsUpdate = true;
            backgroundSphere.material.color.setHSL((hue + 0.5) % 1, 0.5, 0.05);
            
            // Animate particles
            particles.rotation.y = elapsedTime * 0.05;
            const particleColor = particles.geometry.attributes.color;
            for (let i = 0; i < particleCount; i++) {
                const particleHue = (elapsedTime * 0.1 + (positions[i*3] * 0.005)) % 1;
                particleColor.setX(i, new THREE.Color().setHSL(particleHue, 1.0, 0.5).r);
                particleColor.setY(i, new THREE.Color().setHSL(particleHue, 1.0, 0.5).g);
                particleColor.setZ(i, new THREE.Color().setHSL(particleHue, 1.0, 0.5).b);
            }
            particleColor.needsUpdate = true;
            
            controls.update();
            renderer.render(scene, camera);
        }

        // 6. Resize Listener
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });

        animate();
    </script>
</body>
</html>
