<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HugeParticlesAndFlower_Gemini</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style> body { margin: 0; padding: 0; overflow: hidden; background: #000; } canvas { display: block; } </style>
</head>
<body>
    <script>
let particles = [];
let noiseScale = 0.005;
let hueOffset = 0;

function setup() {
  createCanvas(800, 600);
  colorMode(HSB, 360, 100, 100, 100);
  noStroke();
  for (let i = 0; i < 1500; i++) {
    particles.push(new Particle());
  }
  background(0);
}

function draw() {
  // Use a low-alpha background to create motion trails
  background(0, 0, 0, 5);

  // Update and display a background of flowing particles
  let time = frameCount * 0.0003;
  for (let p of particles) {
    let angle = noise(p.pos.x * noiseScale, p.pos.y * noiseScale, time) * TWO_PI * 4;
    let force = p5.Vector.fromAngle(angle);
    force.setMag(0.1);
    p.applyForce(force);
    p.update();
    p.show();
  }

  // Center the main psychedelic form
  translate(width / 2, height / 2);

  // Slowly cycle the base hue over time
  hueOffset = (hueOffset + 0.5) % 360;

  // Mouse interactivity mapping
  // MouseX controls the number of symmetrical sides
  let sides = floor(map(mouseX, 0, width, 3, 16));
  // MouseY controls the overall size/complexity
  let scaleFactor = map(mouseY, 0, height, 0.5, 2.5);
  let speed = frameCount * 0.01;

  // Use ADD blend mode for a glowing, overlapping light effect
  blendMode(ADD);

  // Create multiple layers of rotating shapes for a complex mandala
  for (let j = 0; j < 5; j++) {
    let rotation = speed * (j % 2 === 0 ? 1 : -1) * (j * 0.5 + 1);

    push();
    rotate(rotation);

    for (let i = 0; i < sides; i++) {
      rotate(TWO_PI / sides);

      let layerHue = (hueOffset + i * (360 / sides) + j * 40) % 360;

      // Layer 1: Pulsating core lines
      let len = 50 + sin(speed * 2 + j * PI) * 20;
      len *= scaleFactor;
      stroke(layerHue, 80, 100, 30);
      strokeWeight(map(sin(speed + j), -1, 1, 1, 5));
      line(0, 0, len, 0);

      // Layer 2: Flowing organic curves
      noFill();
      stroke(layerHue, 90, 100, 50);
      strokeWeight(2);
      beginShape();
      for (let k = 0; k < 10; k++) {
        let r = (50 + k * 15) * scaleFactor;
        let angle = sin(speed + k * 0.2 + j) * 0.5;
        curveVertex(r * cos(angle), r * sin(angle));
      }
      endShape();

      // Layer 3: Outer glowing orbs that orbit
      let orbRadius = 180 * scaleFactor + sin(speed * 3 + i) * 50;
      let orbX = cos(i * 0.5 + speed / 2) * orbRadius;
      let orbY = sin(i * 0.5 + speed / 2) * orbRadius;
      let orbSize = 10 + cos(speed * 2 + j) * 8;
      fill(layerHue, 100, 100, 20);
      noStroke();
      ellipse(orbX, orbY, orbSize * 2, orbSize * 2);
    }
    pop();
  }

  // Reset blend mode for the next frame
  blendMode(BLEND);
}

// Reset the background on mouse click for a flashing effect and palette change
function mousePressed() {
  background(0);
  hueOffset = random(360);
}

// Particle class for the background starfield/nebula
class Particle {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.maxSpeed = 2;
    this.history = [];
  }

  update() {
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);

    // Store a history of positions for the tail
    this.history.push(this.pos.copy());
    if (this.history.length > 20) {
      this.history.splice(0, 1);
    }

    this.edges();
  }

  applyForce(force) {
    this.acc.add(force);
  }

  show() {
    let h = (hueOffset + map(this.pos.x, 0, width, 0, 60)) % 360;
    
    // Draw a fading tail
    noFill();
    beginShape();
    for (let i = 0; i < this.history.length; i++) {
      let pos = this.history[i];
      let a = map(i, 0, this.history.length, 0, 15);
      strokeWeight(map(i, 0, this.history.length, 0, 1.5));
      stroke(h, 50, 100, a);
      vertex(pos.x, pos.y);
    }
    endShape();

    // Draw the head of the particle
    stroke(h, 50, 100, 40);
    strokeWeight(2);
    point(this.pos.x, this.pos.y);
  }

  edges() {
    // Wrap around the screen
    if (this.pos.x > width + 10) {
      this.pos.x = -10;
      this.history = [];
    }
    if (this.pos.x < -10) {
      this.pos.x = width + 10;
      this.history = [];
    }
    if (this.pos.y > height + 10) {
      this.pos.y = -10;
      this.history = [];
    }
    if (this.pos.y < -10) {
      this.pos.y = height + 10;
      this.history = [];
    }
  }
}
    </script>
</body>
</html>
