<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trippy GUI Components</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.run/three",
            "three/addons/": "https://esm.run/three/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        let scene, camera, renderer, controls;
        let clock = new THREE.Clock();

        let pulsatingButton, morphingToggle, wavySlider, sliderNub, glitchPanel;
        let morphingToggleOriginalPositions;

        function init() {
            // Scene
            scene = new THREE.Scene();
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(2);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const pointLight1 = new THREE.PointLight(0xff00ff, 2, 50);
            pointLight1.position.set(-10, 10, 5);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x00ffff, 2, 50);
            pointLight2.position.set(10, -10, -5);
            scene.add(pointLight2);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            createTrippyGUI();

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function createTrippyGUI() {
            // 1. Pulsating Button (TorusKnot)
            const buttonGeo = new THREE.TorusKnotGeometry(1.5, 0.3, 200, 20);
            const buttonMat = new THREE.MeshStandardMaterial({ 
                color: 0xff00ff, 
                metalness: 0.8, 
                roughness: 0.1,
                emissive: 0x330033
            });
            pulsatingButton = new THREE.Mesh(buttonGeo, buttonMat);
            pulsatingButton.position.set(-6, 3, 0);
            scene.add(pulsatingButton);
            
            // 2. Morphing Toggle (Icosahedron)
            const toggleGeo = new THREE.IcosahedronGeometry(1.5, 1);
            morphingToggleOriginalPositions = toggleGeo.attributes.position.clone();
            const toggleMat = new THREE.MeshNormalMaterial({ flatShading: true });
            morphingToggle = new THREE.Mesh(toggleGeo, toggleMat);
            morphingToggle.position.set(6, -3, 0);
            scene.add(morphingToggle);

            // 3. Wavy Slider (Tube)
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-8, -4, -4),
                new THREE.Vector3(-4, -2, 4),
                new THREE.Vector3(4, 2, -4),
                new THREE.Vector3(8, 4, 4)
            ]);
            const tubeGeo = new THREE.TubeGeometry(curve, 64, 0.2, 8, false);
            const tubeMat = new THREE.MeshStandardMaterial({
                metalness: 0.5,
                roughness: 0.2,
                vertexColors: true,
                emissive: 0x111111
            });
            
            const colors = [];
            const color = new THREE.Color();
            for (let i = 0; i < tubeGeo.attributes.position.count; i++) {
                color.setHSL(i / tubeGeo.attributes.position.count, 1.0, 0.5);
                colors.push(color.r, color.g, color.b);
            }
            tubeGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            wavySlider = new THREE.Mesh(tubeGeo, tubeMat);
            scene.add(wavySlider);
            
            // Slider Nub
            const nubGeo = new THREE.SphereGeometry(0.5, 32, 32);
            const nubMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 1.0,
                roughness: 0.1,
                emissive: 0x222222
            });
            sliderNub = new THREE.Mesh(nubGeo, nubMat);
            sliderNub.curve = curve; // Attach curve for animation
            scene.add(sliderNub);

            // 4. Glitch Panel (ShaderMaterial)
            const panelGeo = new THREE.PlaneGeometry(8, 8, 32, 32);
            const panelMat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 1.0 },
                    colorA: { value: new THREE.Color(0x7f00ff) },
                    colorB: { value: new THREE.Color(0x00f2ff) }
                },
                vertexShader: `
                    uniform float time;
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        vec3 pos = position;
                        float sine = sin(pos.x * 2.0 + time) * 0.2;
                        float cosine = cos(pos.y * 2.0 + time) * 0.2;
                        pos.z += sine + cosine;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 colorA;
                    uniform vec3 colorB;
                    varying vec2 vUv;
                    void main() {
                        vec2 p = vUv * 8.0 - vec2(20.0);
                        float a = atan(p.y, p.x);
                        float r = length(p);
                        float colorVal = 0.5 + 0.5 * sin(r * 2.0 - a * 3.0 + time * 3.0);
                        vec3 finalColor = mix(colorA, colorB, colorVal);
                        gl_FragColor = vec4(finalColor, 0.8);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            glitchPanel = new THREE.Mesh(panelGeo, panelMat);
            glitchPanel.position.set(0, 0, -4);
            scene.add(glitchPanel);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            
            // Animate Pulsating Button
            const scale = 1 + Math.sin(elapsedTime * 2) * 0.1;
            pulsatingButton.scale.set(scale, scale, scale);
            pulsatingButton.rotation.x = elapsedTime * 0.2;
            pulsatingButton.rotation.y = elapsedTime * 0.3;
            pulsatingButton.material.emissive.setHSL((elapsedTime * 0.1) % 1, 0.8, 0.3);

            // Animate Morphing Toggle
            const positions = morphingToggle.geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const ox = morphingToggleOriginalPositions.getX(i);
                const oy = morphingToggleOriginalPositions.getY(i);
                const oz = morphingToggleOriginalPositions.getZ(i);
                
                const vec = new THREE.Vector3(ox, oy, oz).normalize();
                const amp = 0.5 * Math.sin(elapsedTime * 3 + i * 0.5);
                vec.multiplyScalar(amp);

                positions.setXYZ(i, ox + vec.x, oy + vec.y, oz + vec.z);
            }
            positions.needsUpdate = true;
            morphingToggle.rotation.y += 0.005;
            morphingToggle.rotation.x += 0.005;

            // Animate Slider Nub
            const t = (Math.sin(elapsedTime * 0.5) + 1) / 2; // Loop 0 to 1
            const positionOnCurve = sliderNub.curve.getPointAt(t);
            sliderNub.position.copy(positionOnCurve);

            // Animate Glitch Panel
            glitchPanel.material.uniforms.time.value = elapsedTime;
            
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
