<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TrippyRainbowSpiderSwirl</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style> body { margin: 0; padding: 0; overflow: hidden; background: #000; } canvas { display: block; } </style>
</head>
<body>
    <script>
let time = 0;
let particles = [];
let hueShift = 0;

function setup() {
  createCanvas(800, 600);
  colorMode(HSB, 360, 100, 100, 100);
  angleMode(DEGREES);
  noStroke();
  rectMode(CENTER);
}

function draw() {
  // A dark, slightly shifting background with a low alpha for motion trails
  background(hueShift % 360, 10, 5, 8);
  hueShift += 0.2;

  // Center the coordinate system for the main visuals
  translate(width / 2, height / 2);

  // Mouse interactivity mapping
  let numArms = floor(map(mouseX, 0, width, 2, 20));
  let chaos = map(mouseY, 0, height, 0.2, 5);

  // Draw the central, morphing "portal"
  drawPortal(chaos);

  // Draw the main radiating, hypnotic arms
  for (let i = 0; i < numArms; i++) {
    push();
    rotate((360 / numArms) * i + time * 5);
    drawArm(chaos);
    pop();
  }

  // Particle system for an extra layer of energy
  if (frameCount % 2 === 0) {
    particles.push(new Particle(chaos));
  }

  // Update and display particles from the end of the array backwards
  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    particles[i].show();
    if (particles[i].isFinished()) {
      particles.splice(i, 1);
    }
  }

  // Update global time
  time += 0.005;
}

function drawPortal(chaos) {
  let portalRadius = 150 + sin(time * 150) * 40;
  let portalHue = (frameCount * 0.8) % 360;

  for (let k = 10; k > 0; k--) {
    fill((portalHue + k * 20) % 360, 95, 100, 12);
    beginShape();
    let r = portalRadius * 0.4 + k * 18;
    for (let a = 0; a < 360; a += 4) {
      let noiseVal = noise(
        cos(a) * 0.7,
        sin(a) * 0.7,
        time * chaos * 0.5 + k * 0.05
      );
      let offset = map(noiseVal, 0, 1, -50, 50);
      let x = cos(a) * (r + offset);
      let y = sin(a) * (r + offset);
      curveVertex(x, y);
    }
    endShape(CLOSE);
  }
}

function drawArm(chaos) {
  for (let j = 0; j < 50; j++) {
    let dist = j * 12 + 80;
    let angle = time * 200 * chaos + pow(j, 1.6);
    
    let x = sin(angle) * dist * 0.3;
    let y = dist;

    let noiseFactor = noise(x * 0.01, y * 0.01, time * chaos);
    let size = map(noiseFactor, 0, 1, 2, 20) * (1 + j * 0.03);
    
    let hue = (frameCount * 1.5 + j * 8) % 360;
    let brightness = map(sin(time * 300 + j * 15), -1, 1, 70, 100);
    let alpha = map(j, 0, 50, 90, 0);

    push();
    translate(x, y);
    rotate(angle);
    fill(hue, 95, brightness, alpha);
    let shapeType = floor(noise(j * 0.1, time * chaos) * 3);
    if (shapeType === 0) {
       rect(0, 0, size, size);
    } else if (shapeType === 1){
       ellipse(0, 0, size, size);
    } else {
       triangle(0, -size/2, -size/2, size/2, size/2, size/2);
    }
    pop();
  }
}

class Particle {
  constructor(chaos) {
    this.pos = createVector(0, 0);
    this.vel = p5.Vector.random2D().mult(random(2, 6) * chaos * 0.5);
    this.acc = createVector(0, 0);
    this.lifespan = 100;
    this.hue = (frameCount * 0.8 + random(-30, 30)) % 360;
    this.size = random(2, 6);
  }

  isFinished() {
    return this.lifespan < 0;
  }
  
  applyForce(force) {
    this.acc.add(force);
  }

  update() {
    // Add a swirling force based on Perlin noise
    let angle = noise(this.pos.x * 0.005, this.pos.y * 0.005, time) * 360 * 4;
    let swirlForce = p5.Vector.fromAngle(angle);
    swirlForce.mult(0.1);
    this.applyForce(swirlForce);
    
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.vel.mult(0.97); // Drag
    this.acc.mult(0); // Clear acceleration
    this.lifespan -= 1.8;
  }

  show() {
    fill(this.hue, 100, 100, this.lifespan);
    ellipse(this.pos.x, this.pos.y, this.size, this.size);
  }
}
    </script>
</body>
</html>
