<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generative Phyllotaxis Bloom</title>
    <style>
        :root {
            --background-color: #000000;
            --primary-color: #ffffff;
            --bloom-strength: 1.2;
            --bloom-radius: 0.5;
            --bloom-threshold: 0.05;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--background-color);
        }
        .phyllotaxis-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="phyllotaxis-canvas" class="phyllotaxis-canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        window.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('phyllotaxis-canvas');
            const width = window.innerWidth;
            const height = window.innerHeight;

            // --- Scene Setup ---
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.02);
            window.scene = scene; // Expose scene for potential external access

            const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
            camera.position.set(0, 20, 40);

            const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", canvas });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // --- Controls ---
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // --- Generative Geometry (Phyllotaxis) ---
            const count = 3000; // Number of seeds
            const geometry = new THREE.IcosahedronGeometry(0.5, 0);
            const material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                wireframe: true
            });

            // Using InstancedMesh for performance
            const mesh = new THREE.InstancedMesh(geometry, material, count);
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(mesh);

            // Pre-allocate helper objects
            const dummy = new THREE.Object3D();
            const color = new THREE.Color();
            
            // --- Post-Processing (Bloom) ---
            const renderScene = new THREE.RenderPass(scene, camera);
            
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(width, height),
                1.2,  // Strength
                0.5,  // Radius
                0.05  // Threshold
            );

            const composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // --- Animation Loop ---
            const clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);

                const time = clock.getElapsedTime();
                controls.update();

                // Phyllotaxis Parameters
                const angleBase = 137.5 * (Math.PI / 180); 
                const divergence = angleBase + Math.sin(time * 0.2) * 0.005; 
                
                // Breathing expansion
                const spread = 0.6 + Math.sin(time * 0.5) * 0.05;

                // Iterate through instances
                for (let i = 0; i < count; i++) {
                    // Calculate phyllotaxis coordinates
                    const r = spread * Math.sqrt(i);
                    const theta = i * divergence;

                    const x = r * Math.cos(theta);
                    const y = r * Math.sin(theta);
                    
                    // Shape shifting Z-height (creating a bowl/wave effect)
                    const z = Math.sin(r * 0.3 - time * 0.8) * 2.0 - (r * r * 0.01);

                    dummy.position.set(x, z, y);
                    
                    // Rotate individual seeds to look at center or flow
                    dummy.lookAt(0, 0, 0);
                    
                    // Scale breathing
                    const scale = 1.0 - (i / count) * 0.5 + Math.sin(time * 2 + i * 0.1) * 0.2;
                    dummy.scale.setScalar(Math.max(0.1, scale));

                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);

                    // Dynamic Color
                    const hue = (i * 0.0005 + time * 0.05) % 1;
                    const lightness = 0.5 + Math.sin(time + i * 0.01) * 0.2; // Pulse brightness
                    color.setHSL(hue, 1.0, lightness);
                    mesh.setColorAt(i, color);
                }

                mesh.instanceMatrix.needsUpdate = true;
                if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;

                // Slow rotation of the entire flower structure
                mesh.rotation.y = time * 0.05;
                mesh.rotation.z = Math.sin(time * 0.2) * 0.1;

                composer.render();
            }

            // --- Resize Handler ---
            window.addEventListener('resize', () => {
                const newWidth = window.innerWidth;
                const newHeight = window.innerHeight;
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
                composer.setSize(newWidth, newHeight);
            });

            animate();
        });
    </script>
</body>
</html>
