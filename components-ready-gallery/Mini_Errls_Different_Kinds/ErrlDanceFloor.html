<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ERRL on the Dance Floor</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
    </style>
</head>
<body>
<script type="module">
    import * as THREE from 'https://esm.run/three';
    import { OrbitControls } from 'https://esm.run/three/examples/jsm/controls/OrbitControls.js';

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x101015);
    scene.fog = new THREE.Fog(0x101015, 15, 50);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 12, 25);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 2.0;
    controls.target.set(0, 3, 0);

    // --- Lighting ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambientLight);

    // Disco lights
    const lights = [];
    const lightColors = [0xff0055, 0x00ff55, 0x5500ff, 0xffff00];
    for(let i=0; i<4; i++) {
        const light = new THREE.PointLight(lightColors[i], 2, 30);
        light.position.set((Math.random() - 0.5) * 20, 10, (Math.random() - 0.5) * 20);
        scene.add(light);
        lights.push(light);
    }

    // --- Voxel Generation ---
    const voxelSize = 1;
    const gap = 0.05;
    const geometry = new THREE.BoxGeometry(voxelSize - gap, voxelSize - gap, voxelSize - gap);
    
    // Material cache to avoid creating too many materials, though we will animate colors
    const materialBase = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.1,
        metalness: 0.1,
        emissive: 0x000000,
        emissiveIntensity: 0.5
    });

    const voxels = [];
    const floorVoxels = [];

    function createVoxel(x, y, z, type) {
        const material = materialBase.clone();
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, y, z);
        
        // Initial color
        const hue = (x + 10) / 20; 
        material.color.setHSL(hue, 1.0, 0.5);
        
        scene.add(mesh);
        
        if (type === 'text') {
            voxels.push({ mesh, baseX: x, baseY: y, baseZ: z, offset: Math.random() * Math.PI * 2 });
        } else {
            floorVoxels.push({ mesh, x, z });
        }
    }

    // --- Letter Definitions (5x7 Grid) ---
    const fontMap = {
        'E': [
            "XXXX",
            "X   ",
            "X   ",
            "XXX ",
            "X   ",
            "X   ",
            "XXXX"
        ],
        'R': [
            "XXX ",
            "X  X",
            "X  X",
            "XXX ",
            "X X ",
            "X  X",
            "X  X"
        ],
        'L': [
            "X   ",
            "X   ",
            "X   ",
            "X   ",
            "X   ",
            "X   ",
            "XXXX"
        ]
    };

    // Construct "ERRL"
    const word = "ERRL";
    let currentX = -9; 

    for (let l = 0; l < word.length; l++) {
        const char = word[l];
        const map = fontMap[char];
        
        // Draw letter from top to bottom in map, so reverse Y index
        for (let row = 0; row < 7; row++) {
            const rowStr = map[row]; // Top row is index 0
            const y = 6 - row; // Map 0->6, 1->5 ...
            
            for (let col = 0; col < rowStr.length; col++) {
                if (rowStr[col] === 'X') {
                    createVoxel(currentX + col, y + 1, 0, 'text'); // Lifted y+1
                }
            }
        }
        currentX += 5; // Move cursor
    }

    // --- Dance Floor ---
    const floorSize = 24;
    for (let x = -floorSize / 2; x < floorSize / 2; x++) {
        for (let z = -floorSize / 2; z < floorSize / 2; z++) {
            createVoxel(x, 0, z, 'floor');
        }
    }

    // --- Animation Loop ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const time = clock.getElapsedTime();
        const delta = clock.getDelta();

        controls.update();

        // Animate Lights
        lights.forEach((light, i) => {
            light.position.x = Math.sin(time * 0.5 + i * 2) * 10;
            light.position.z = Math.cos(time * 0.7 + i * 2) * 10;
            light.position.y = 8 + Math.sin(time * 2 + i) * 2;
        });

        // Animate Text Voxels (Bobbing + Color Cycle)
        voxels.forEach(v => {
            // Vertical bob
            v.mesh.position.y = v.baseY + Math.sin(time * 5 + v.baseX * 0.5) * 0.2;
            
            // Color cycle
            const hue = (v.baseX * 0.05 + time * 0.2) % 1;
            v.mesh.material.color.setHSL(hue, 1.0, 0.5);
            v.mesh.material.emissive.setHSL(hue, 1.0, 0.2);
        });

        // Animate Floor (Disco pattern)
        // We won't update every frame to save performance, just use a math pattern
        floorVoxels.forEach(v => {
            const dist = Math.sqrt(v.x*v.x + v.z*v.z);
            // Radial ripple
            const hue = (dist * 0.1 - time * 0.5) % 1;
            const brightness = Math.max(0.1, 0.5 + 0.5 * Math.sin(dist * 0.5 - time * 3));
            
            // Checkerboard effect
            const check = (Math.floor(v.x + time) + Math.floor(v.z)) % 2 === 0;
            
            if(check) {
                v.mesh.material.color.setHSL(hue, 0.8, brightness * 0.5);
                v.mesh.material.emissive.setHSL(hue, 0.8, brightness * 0.2);
            } else {
                v.mesh.material.color.setHSL((hue + 0.5) % 1, 0.8, brightness * 0.1);
                v.mesh.material.emissive.setHex(0x000000);
            }
        });

        renderer.render(scene, camera);
    }

    // --- Resize Handler ---
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>