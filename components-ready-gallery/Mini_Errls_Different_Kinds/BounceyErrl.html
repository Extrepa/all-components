<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BounceyErrl</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style> body { margin: 0; padding: 0; overflow: hidden; background: #000; } canvas { display: block; } </style>
</head>
<body>
    <script>
/**
 * Interactive Buddy Clone
 * 
 * Instructions:
 * - Click and Drag the buddy to throw him around.
 * - Throw him at the walls or floor to see him bounce.
 * - Move the mouse to have him look at you.
 * - The physics are simulated using a custom spring-mass system.
 */

let buddy;

function setup() {
  createCanvas(800, 600);
  buddy = new Buddy(width / 2, height / 2);
  strokeCap(ROUND);
  strokeJoin(ROUND);
}

function draw() {
  background(240);
  
  // Draw Floor
  noStroke();
  fill(200);
  rect(0, height - 20, width, 20);

  // Physics and Drawing
  buddy.update();
  buddy.display();
  
  // Instructions
  fill(150);
  textAlign(CENTER);
  textSize(14);
  text("Click & Drag to interact", width/2, height - 30);
}

function mousePressed() {
  buddy.checkClick();
}

function mouseReleased() {
  buddy.release();
}

class Buddy {
  constructor(x, y) {
    // Main body particle
    this.head = new Particle(x, y, 0.95); // Higher drag for head
    
    // Limbs (Feet and Arms)
    // They will be connected via springs to offset points relative to the head
    this.footL = new Particle(x - 30, y + 100, 0.90);
    this.footR = new Particle(x + 30, y + 100, 0.90);
    this.handL = new Particle(x - 70, y + 50, 0.90);
    this.handR = new Particle(x + 70, y + 50, 0.90);
    
    this.isDragging = false;
    this.dragOffset = createVector(0,0);
    
    // Face Animation
    this.blinkTimer = 0;
    this.isBlinking = false;
  }

  update() {
    // Physics Constants
    let gravity = createVector(0, 0.5);
    let k = 0.1; // Spring stiffness
    let damp = 0.8; // Spring damping

    // 1. Update Head Interaction
    if (this.isDragging) {
      this.head.pos.x = mouseX + this.dragOffset.x;
      this.head.pos.y = mouseY + this.dragOffset.y;
      this.head.vel.mult(0); // Zero velocity while holding
    } else {
      this.head.applyForce(gravity);
      this.head.update();
    }
    this.head.constrainBounds(90); // Radius approximation

    // 2. Calculate Anchor Points relative to Head
    // As the head rotates or moves, these maintain structure
    // Simple vertical orientation for now, could add rotation matrix if we wanted tumbling
    let bodyX = this.head.pos.x;
    let bodyY = this.head.pos.y;

    // Anchor positions (where the limbs "should" be)
    let targetFootL = createVector(bodyX - 35, bodyY + 90);
    let targetFootR = createVector(bodyX + 35, bodyY + 90);
    let targetHandL = createVector(bodyX - 75, bodyY + 40);
    let targetHandR = createVector(bodyX + 75, bodyY + 40);

    // 3. Apply Spring Forces to Limbs
    this.applySpring(this.footL, targetFootL, k, damp);
    this.applySpring(this.footR, targetFootR, k, damp);
    this.applySpring(this.handL, targetHandL, k * 0.8, damp); // Arms slightly looser
    this.applySpring(this.handR, targetHandR, k * 0.8, damp);

    // 4. Update Limbs Physics
    let limbList = [this.footL, this.footR, this.handL, this.handR];
    for (let limb of limbList) {
      limb.applyForce(gravity);
      limb.update();
      limb.constrainBounds(25); // Limb radius
    }
    
    // Leg Floor Collision helper (to make him stand somewhat)
    // If feet are below floor threshold, push up slightly more to simulate standing stiffness
    if(this.footL.pos.y > height - 50) this.footL.pos.y = lerp(this.footL.pos.y, height-50, 0.2);
    if(this.footR.pos.y > height - 50) this.footR.pos.y = lerp(this.footR.pos.y, height-50, 0.2);
  }

  applySpring(particle, target, k, damp) {
    let force = p5.Vector.sub(target, particle.pos);
    force.mult(k);
    particle.applyForce(force);
    
    // Damping on particle to stop oscillation
    particle.vel.mult(damp); 
  }

  display() {
    // Define Buddy Color
    let cBody = color(46, 34, 110); // Dark Purple/Blue
    
    // Use thick lines to simulate the blob body
    stroke(cBody);
    
    // Legs
    strokeWeight(55);
    line(this.head.pos.x - 20, this.head.pos.y + 30, this.footL.pos.x, this.footL.pos.y);
    line(this.head.pos.x + 20, this.head.pos.y + 30, this.footR.pos.x, this.footR.pos.y);
    
    // Arms
    strokeWeight(45);
    line(this.head.pos.x - 40, this.head.pos.y + 10, this.handL.pos.x, this.handL.pos.y);
    line(this.head.pos.x + 40, this.head.pos.y + 10, this.handR.pos.x, this.handR.pos.y);
    
    // Body/Head Main shape
    noStroke();
    fill(cBody);
    circle(this.head.pos.x, this.head.pos.y, 170);

    // Fill gaps for smoother blob look
    // A rect to bridge head and legs visually
    rectMode(CENTER);
    rect(this.head.pos.x, this.head.pos.y + 40, 100, 80, 20);

    this.drawFace();
  }

  drawFace() {
    let hx = this.head.pos.x;
    let hy = this.head.pos.y;
    
    // Face Mask (White Circle)
    // Offset slightly based on mouse position (Looking)
    let lookX = constrain((mouseX - hx) * 0.1, -15, 15);
    let lookY = constrain((mouseY - hy) * 0.1, -15, 15);
    
    fill(255);
    noStroke();
    // The face is slightly offset to the left in the reference, 
    // but we'll center it dynamically + look offset
    let faceX = hx + lookX - 5; 
    let faceY = hy + lookY + 5;
    circle(faceX, faceY, 115);

    // Eyes
    fill(46, 34, 110);
    
    // Blink Logic
    this.blinkTimer++;
    if (this.blinkTimer > 150 && random() < 0.05) {
      this.isBlinking = true;
      this.blinkTimer = 0;
    }
    if (this.blinkTimer > 10) this.isBlinking = false;

    if (this.isBlinking) {
      // Blink lines
      stroke(46, 34, 110);
      strokeWeight(4);
      line(faceX - 30, faceY - 10, faceX - 10, faceY - 10);
      line(faceX + 10, faceY - 10, faceX + 30, faceY - 10);
      noStroke();
    } else {
      // Open Eyes (Ovals)
      ellipse(faceX - 20, faceY - 15, 22, 38);
      ellipse(faceX + 20, faceY - 15, 22, 38);
    }

    // Mouth
    // React to velocity (Surprise/Wheee)
    let speed = this.head.vel.mag();
    let mouthH = map(speed, 0, 20, 15, 35); 
    mouthH = constrain(mouthH, 15, 35);
    ellipse(faceX, faceY + 35, 30, mouthH * 0.6);
  }

  checkClick() {
    let d = dist(mouseX, mouseY, this.head.pos.x, this.head.pos.y);
    if (d < 90) {
      this.isDragging = true;
      this.dragOffset.x = this.head.pos.x - mouseX;
      this.dragOffset.y = this.head.pos.y - mouseY;
    }
  }

  release() {
    if (this.isDragging) {
      this.isDragging = false;
      // Throw Physics
      let throwForce = createVector(mouseX - pwinMouseX, mouseY - pwinMouseY);
      throwForce.mult(1.5); // Add some power
      this.head.vel.add(throwForce);
    }
  }
}

class Particle {
  constructor(x, y, drag) {
    this.pos = createVector(x, y);
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.drag = drag || 0.96;
    this.mass = 1;
  }

  applyForce(force) {
    this.acc.add(force);
  }

  update() {
    this.vel.add(this.acc);
    this.vel.mult(this.drag);
    this.pos.add(this.vel);
    this.acc.mult(0);
  }

  constrainBounds(radius) {
    // Floor
    if (this.pos.y > height - radius - 20) { // -20 for floor rect
      this.pos.y = height - radius - 20;
      this.vel.y *= -0.6; // Bounce
      this.vel.x *= 0.8; // Floor Friction
    }
    // Walls
    if (this.pos.x > width - radius) {
      this.pos.x = width - radius;
      this.vel.x *= -0.6;
    }
    if (this.pos.x < radius) {
      this.pos.x = radius;
      this.vel.x *= -0.6;
    }
    // Ceiling
    if (this.pos.y < radius) {
      this.pos.y = radius;
      this.vel.y *= -0.6;
    }
  }
}
    </script>
</body>
</html>