<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Oil and Water Golem</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body { margin: 0; overflow: hidden; background-color: #000; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script type="module">
			import * as THREE from 'https://esm.run/three';
			import { OrbitControls } from 'https://esm.run/three/examples/jsm/controls/OrbitControls.js';

			let scene, camera, renderer, controls, golemMaterial, clock;

			function init() {
				// Scene setup
				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xF0EAD6); // Overhead projector bright background

				// Camera setup
				camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
				camera.position.set(0, 1.5, 5);

				// Renderer setup
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setPixelRatio(2);
				document.body.appendChild(renderer.domElement);

				// Clock
				clock = new THREE.Clock();
                
				// --- Custom Shader Material ---
				const vertexShader = `
					varying vec3 vWorldPosition;
					varying vec3 vNormal;
					
					void main() {
						vNormal = normalize(normalMatrix * normal);
						vec4 worldPosition = modelMatrix * vec4(position, 1.0);
						vWorldPosition = worldPosition.xyz;
						gl_Position = projectionMatrix * viewMatrix * worldPosition;
					}
				`;

				const fragmentShader = `
					uniform float uTime;
                    varying vec3 vWorldPosition;
					varying vec3 vNormal;
					
					// Classic Perlin 3D Noise by Stefan Gustavson
					// https://github.com/stegu/webgl-noise/blob/master/src/classicnoise3D.glsl
					vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
					vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

					float snoise(vec3 v){
						const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
						const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

						vec3 i  = floor(v + dot(v, C.yyy) );
						vec3 x0 =   v - i + dot(i, C.xxx) ;

						vec3 g = step(x0.yzx, x0.xyz);
						vec3 l = 1.0 - g;
						vec3 i1 = min( g.xyz, l.zxy );
						vec3 i2 = max( g.xyz, l.zxy );

						vec3 x1 = x0 - i1 + C.xxx;
						vec3 x2 = x0 - i2 + C.yyy; 
						vec3 x3 = x0 - D.yyy;      

						i = mod(i, 289.0);
						vec4 p = permute( permute( permute(
									i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
								+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
								+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

						float n_ = 0.142857142857; 
						vec3  ns = n_ * D.wyz - D.xzx;

						vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

						vec4 x_ = floor(j * ns.z);
						vec4 y_ = floor(j - 7.0 * x_);

						vec4 x = x_ *ns.x + ns.yyyy;
						vec4 y = y_ *ns.x + ns.yyyy;
						vec4 h = 1.0 - abs(x) - abs(y);

						vec4 b0 = vec4( x.xy, y.xy );
						vec4 b1 = vec4( x.zw, y.zw );

						vec4 s0 = floor(b0)*2.0 + 1.0;
						vec4 s1 = floor(b1)*2.0 + 1.0;
						vec4 sh = -step(h, vec4(0.0));

						vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
						vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

						vec3 p0 = vec3(a0.xy,h.x);
						vec3 p1 = vec3(a0.zw,h.y);
						vec3 p2 = vec3(a1.xy,h.z);
						vec3 p3 = vec3(a1.zw,h.w);

						vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
						p0 *= norm.x;
						p1 *= norm.y;
						p2 *= norm.z;
						p3 *= norm.w;

						vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
						m = m * m;
						return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
														dot(p2,x2), dot(p3,x3) ) );
					}
                    
                    float fbm(vec3 p) {
                        float value = 0.0;
                        float amplitude = 0.5;
                        float frequency = 1.0;
                        for (int i = 0; i < 5; i++) {
                            value += amplitude * snoise(p * frequency);
                            amplitude *= 0.5;
                            frequency *= 2.0;
                        }
                        return value;
                    }

					void main() {
                        vec3 pos = vWorldPosition * 0.8;
                        float time = uTime * 0.2;

                        // Create two swirling noise patterns
                        float noise1 = fbm(pos + vec3(time, 0.0, time * 0.5));
                        float noise2 = fbm(pos - vec3(0.0, time * 0.7, time * 0.2) + 10.0);
                        
                        // Combine noises to create blobby separation
                        float combinedNoise = (noise1 + noise2) * 0.5;
                        float blobMask = smoothstep(0.0, 0.15, combinedNoise);

                        // Define oil and water colors
						vec3 waterColor = vec3(0.1, 0.3, 0.9);
                        vec3 oilColor = vec3(1.0, 0.7, 0.1);
                        
                        // Mix colors
                        vec3 finalColor = mix(waterColor, oilColor, blobMask);
						
						// Add a darker color for depth
						vec3 darkColor = vec3(0.6, 0.1, 0.8);
						finalColor = mix(finalColor, darkColor, smoothstep(0.3, 0.35, noise1));

						// Fresnel effect for projector glassiness
						float fresnel = 1.0 - dot(normalize(vNormal), vec3(0.0, 0.0, 1.0));
						fresnel = pow(fresnel, 3.0);
						finalColor += fresnel * 0.5;
						
						// Add slight transparency
                        gl_FragColor = vec4(finalColor, 0.9);
					}
				`;

				golemMaterial = new THREE.ShaderMaterial({
					vertexShader,
					fragmentShader,
					uniforms: {
						uTime: { value: 0.0 }
					},
					transparent: true,
					blending: THREE.NormalBlending
				});

				// --- Golem Creation ---
				const golem = new THREE.Group();
				scene.add(golem);

				// Torso
				const torsoGeo = new THREE.SphereGeometry(1.2, 64, 64);
				const torso = new THREE.Mesh(torsoGeo, golemMaterial);
				torso.scale.set(1, 1.3, 0.8);
				golem.add(torso);

				// Head
				const headGeo = new THREE.SphereGeometry(0.8, 64, 64);
				const head = new THREE.Mesh(headGeo, golemMaterial);
				head.position.y = 2.0;
				golem.add(head);

				// Limbs
				const limbGeo = new THREE.SphereGeometry(0.5, 32, 32);
				
				const rightArm = new THREE.Mesh(limbGeo, golemMaterial);
				rightArm.position.set(-1.2, 0.5, 0);
				rightArm.scale.set(0.8, 1.8, 0.8);
				golem.add(rightArm);
				
				const leftArm = new THREE.Mesh(limbGeo, golemMaterial);
				leftArm.position.set(1.2, 0.5, 0);
				leftArm.scale.set(0.8, 1.8, 0.8);
				golem.add(leftArm);
				
				const rightLeg = new THREE.Mesh(limbGeo, golemMaterial);
				rightLeg.position.set(-0.6, -1.5, 0);
				rightLeg.scale.set(1, 2, 1);
				golem.add(rightLeg);
				
				const leftLeg = new THREE.Mesh(limbGeo, golemMaterial);
				leftLeg.position.set(0.6, -1.5, 0);
				leftLeg.scale.set(1, 2, 1);
				golem.add(leftLeg);

				// --- Face Features ---
				const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
				
				// Eyes
				const eyeGeo = new THREE.SphereGeometry(0.2, 32, 32);
				const leftEye = new THREE.Mesh(eyeGeo, eyeMaterial);
				leftEye.position.set(-0.35, 0.1, 0.65);
				head.add(leftEye);

				const rightEye = new THREE.Mesh(eyeGeo, eyeMaterial);
				rightEye.position.set(0.35, 0.1, 0.65);
				head.add(rightEye);
				
				// Awe-like Mouth
				const mouthGeo = new THREE.TorusGeometry(0.25, 0.08, 16, 100);
				const mouth = new THREE.Mesh(mouthGeo, eyeMaterial);
				mouth.position.set(0, -0.3, 0.6);
				head.add(mouth);

				// Controls
				controls = new OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true;
				controls.dampingFactor = 0.05;
                controls.minDistance = 3;
                controls.maxDistance = 15;
                controls.target.set(0, 1, 0);

				// Window resize listener
				window.addEventListener('resize', onWindowResize, false);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				requestAnimationFrame(animate);

				const elapsedTime = clock.getElapsedTime();
				golemMaterial.uniforms.uTime.value = elapsedTime;

				controls.update();
				renderer.render(scene, camera);
			}

			init();
			animate();
		</script>
	</body>
</html>
