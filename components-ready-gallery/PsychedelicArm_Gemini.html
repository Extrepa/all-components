<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PsychedelicArm_Gemini</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style> body { margin: 0; padding: 0; overflow: hidden; background: #000; } canvas { display: block; } </style>
</head>
<body>
    <script>
let pg;
let hueOffset = 0;
let noiseSeeds = [];

function setup() {
  createCanvas(800, 600);
  pg = createGraphics(800, 600);
  
  colorMode(HSB, 360, 100, 100, 100);
  pg.colorMode(HSB, 360, 100, 100, 100);
  
  background(0);
  pg.background(0);

  // Generate random noise seeds for variety
  for (let i = 0; i < 20; i++) {
    noiseSeeds.push(random(1000));
  }
}

function draw() {
  // --- 1. FEEDBACK & FADE ---
  // Apply transformations for the feedback loop
  pg.push();
  pg.translate(width / 2, height / 2);

  // Mouse interactivity for zoom and rotation
  let zoom = map(mouseX, 0, width, 1.005, 1.03);
  let rot = map(mouseY, 0, height, -0.4, 0.4);
  
  pg.scale(zoom);
  pg.rotate(radians(rot));
  
  pg.translate(-width / 2, -height / 2);
  
  // Draw the previous frame back onto the buffer
  pg.image(pg, 0, 0);
  pg.pop();

  // A very slow fade to black to control brightness and create trails
  pg.noStroke();
  pg.fill(0, 0, 0, 2);
  pg.rect(0, 0, width, height);
  
  // --- 2. GENERATE NEW PATTERNS ---
  hueOffset = (hueOffset + 0.5) % 360;
  
  pg.translate(width / 2, height / 2);
  
  let sides = 10;
  let angle = TWO_PI / sides;
  
  for (let i = 0; i < sides; i++) {
    pg.rotate(angle);
    drawPsychedelicArm(i);
  }
  
  // --- 3. RENDER TO SCREEN ---
  image(pg, 0, 0);

  // --- 4. POST-PROCESSING BLOOM ---
  blendMode(ADD);
  noStroke();
  let bloomHue = (hueOffset + 180) % 360;
  fill(bloomHue, 50, 100, 5);
  rect(0, 0, width, height);
  blendMode(BLEND);
}

function drawPsychedelicArm(index) {
  let t = frameCount * 0.008;
  
  // --- Flowing Organic Shape ---
  pg.noFill();
  pg.strokeWeight(map(sin(t + index), -1, 1, 1, 5));
  let hue1 = (hueOffset + index * 15) % 360;
  pg.stroke(hue1, 90, 100, 25);
  
  pg.beginShape();
  for (let j = 0; j < 5; j++) {
    let r = map(noise(noiseSeeds[j] + t, index * 0.1), 0, 1, 50, 250);
    let a = map(j, 0, 4, 0, PI * 0.5);
    let x = r * cos(a + t * 0.5);
    let y = r * sin(a + t * 0.5);
    pg.curveVertex(x, y);
  }
  pg.endShape();

  // --- Pulsating Orbs ---
  pg.noStroke();
  let hue2 = (hueOffset + index * 15 + 60) % 360;
  pg.fill(hue2, 80, 100, 40);
  
  let r_orb = map(noise(noiseSeeds[5] + t, index * 0.1), 0, 1, 100, 300);
  let size_orb = map(sin(t * 3 + index * PI), -1, 1, 2, 12);
  pg.ellipse(r_orb, 0, size_orb, size_orb);
  
  // --- Sharp Geometric Lines ---
  pg.strokeWeight(map(cos(t * 2 + index), -1, 1, 0.5, 2));
  let hue3 = (hueOffset + 180) % 360;
  pg.stroke(hue3, 70, 100, 30);
  
  let x1 = map(noise(noiseSeeds[6] + t), 0, 1, 0, width / 3);
  let y1 = map(noise(noiseSeeds[7] + t), 0, 1, 0, height / 3);
  let x2 = map(noise(noiseSeeds[8] + t), 0, 1, 0, width / 3);
  let y2 = map(noise(noiseSeeds[9] + t), 0, 1, 0, height / 3);
  pg.line(x1, y1, x2, y2);
}

function mousePressed() {
  // Reset the visuals and generate new noise seeds for a different pattern
  pg.background(0);
  noiseSeeds = [];
  for (let i = 0; i < 20; i++) {
    noiseSeeds.push(random(1000));
  }
}
    </script>
</body>
</html>
