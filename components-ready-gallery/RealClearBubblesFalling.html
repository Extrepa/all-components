<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gooey Iridescent Bubbles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.run/three",
            "three/addons/": "https://esm.run/three/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let bubbles = [];
        const groundY = -10;

        // Particle System
        const MAX_PARTICLES = 5000;
        let particleSystem, particleGeometry;
        let particlePositions, particleColors, particleAlphas, particleVelocities, particleLifes;
        let particleCursor = 0;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x10102a);
            scene.fog = new THREE.Fog(0x10102a, 20, 70);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 25);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(2); // Set pixel ratio
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffddee, 1.5);
            directionalLight1.position.set(5, 10, 7.5);
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xddffdd, 1.0);
            directionalLight2.position.set(-5, 10, -7.5);
            scene.add(directionalLight2);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x202030,
                roughness: 0.4,
                metalness: 0.1,
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = groundY;
            scene.add(ground);

            // Particle System Setup
            initParticles();

            // Spawn first bubble
            setInterval(createBubble, 400);

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function initParticles() {
            particleGeometry = new THREE.BufferGeometry();
            
            particlePositions = new Float32Array(MAX_PARTICLES * 3);
            particleColors = new Float32Array(MAX_PARTICLES * 3);
            particleAlphas = new Float32Array(MAX_PARTICLES);
            particleVelocities = [];
            particleLifes = [];

            const initialColor = new THREE.Color();

            for (let i = 0; i < MAX_PARTICLES; i++) {
                particlePositions[i * 3] = 0;
                particlePositions[i * 3 + 1] = -9999; // Hide initially
                particlePositions[i * 3 + 2] = 0;
                
                initialColor.set(0xffffff);
                particleColors[i * 3] = initialColor.r;
                particleColors[i * 3 + 1] = initialColor.g;
                particleColors[i * 3 + 2] = initialColor.b;
                
                particleAlphas[i] = 0.0;
                
                particleVelocities.push(new THREE.Vector3());
                particleLifes.push(0);
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            particleGeometry.setAttribute('alpha', new THREE.BufferAttribute(particleAlphas, 1));
            
            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    size: { value: 25.0 }
                },
                vertexShader: `
                    attribute float alpha;
                    varying float vAlpha;
                    varying vec3 vColor;
                    attribute vec3 color;
                    void main() {
                        vAlpha = alpha;
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                        gl_PointSize = 10.0 * ( 300.0 / -mvPosition.z );
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying float vAlpha;
                    varying vec3 vColor;
                    void main() {
                        if (vAlpha <= 0.0) discard;
                        float r = 0.0, delta = 0.0, alpha = vAlpha;
                        vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                        r = dot(cxy, cxy);
                        if (r > 1.0) discard;
                        gl_FragColor = vec4( vColor, alpha * (1.0 - r) );
                    }
                `,
                transparent: true,
                vertexColors: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
        }

        function createBubble() {
            const size = Math.random() * 1.5 + 0.5;
            const geometry = new THREE.SphereGeometry(size, 32, 32);
            
            const material = new THREE.MeshPhysicalMaterial({
                roughness: 0,
                metalness: 0.1,
                transmission: 1.0,
                ior: 1.33,
                thickness: 0.2 + Math.random() * 2.0,
                envMapIntensity: 1,
                iridescence: 1,
                iridescenceIOR: 1.3 + Math.random() * 0.4,
                iridescenceThicknessRange: [100, 800 + Math.random() * 200],
            });

            const bubble = new THREE.Mesh(geometry, material);
            bubble.position.set(
                (Math.random() - 0.5) * 40,
                20 + Math.random() * 5,
                (Math.random() - 0.5) * 40
            );

            const bubbleData = {
                mesh: bubble,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.01,
                    -0.03 - Math.random() * 0.05,
                    (Math.random() - 0.5) * 0.01
                ),
                radius: size,
            };

            bubbles.push(bubbleData);
            scene.add(bubble);
        }

        function splatter(position, bubbleRadius) {
            const particleCount = Math.floor(Math.random() * 50 + 20 * bubbleRadius);
            const splatterColor = new THREE.Color().setHSL(Math.random(), 1.0, 0.6);
            
            for (let i = 0; i < particleCount; i++) {
                const pIndex = particleCursor;
                
                particlePositions[pIndex * 3] = position.x;
                particlePositions[pIndex * 3 + 1] = position.y;
                particlePositions[pIndex * 3 + 2] = position.z;

                const hue = (splatterColor.getHSL({h:0,s:0,l:0}).h + (Math.random() - 0.5) * 0.2) % 1.0;
                const particleColor = new THREE.Color().setHSL(hue, 1.0, 0.6);
                particleColors[pIndex * 3] = particleColor.r;
                particleColors[pIndex * 3 + 1] = particleColor.g;
                particleColors[pIndex * 3 + 2] = particleColor.b;

                particleAlphas[pIndex] = 1.0;
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5),
                    Math.random() * 0.8,
                    (Math.random() - 0.5)
                ).normalize().multiplyScalar(Math.random() * 0.2 + 0.05);
                
                particleVelocities[pIndex].copy(velocity);
                particleLifes[pIndex] = 60 + Math.random() * 60; // life in frames
                
                particleCursor = (particleCursor + 1) % MAX_PARTICLES;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update Bubbles
            for (let i = bubbles.length - 1; i >= 0; i--) {
                const b = bubbles[i];
                b.mesh.position.add(b.velocity);
                b.velocity.y -= 0.0001; // Tiny gravity effect

                // Splatter on ground
                if (b.mesh.position.y - b.radius <= groundY) {
                    splatter(b.mesh.position, b.radius);
                    scene.remove(b.mesh);
                    b.mesh.geometry.dispose();
                    b.mesh.material.dispose();
                    bubbles.splice(i, 1);
                }
            }
            
            // Update Particles
            const positions = particleGeometry.attributes.position.array;
            const alphas = particleGeometry.attributes.alpha.array;

            for (let i = 0; i < MAX_PARTICLES; i++) {
                if (particleLifes[i] > 0) {
                    particleLifes[i]--;
                    
                    particleVelocities[i].y -= 0.003; // Particle gravity
                    
                    positions[i * 3] += particleVelocities[i].x;
                    positions[i * 3 + 1] += particleVelocities[i].y;
                    positions[i * 3 + 2] += particleVelocities[i].z;
                    
                    alphas[i] = particleLifes[i] / 120.0;
                    
                    if (positions[i * 3 + 1] <= groundY) {
                         particleLifes[i] = 0;
                    }
                }
                if(particleLifes[i] <= 0){
                    alphas[i] = 0.0;
                }
            }

            particleGeometry.attributes.position.needsUpdate = true;
            particleGeometry.attributes.alpha.needsUpdate = true;
            
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
