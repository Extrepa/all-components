<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RainbowSwirlsMandala</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style> body { margin: 0; padding: 0; overflow: hidden; background: #000; } canvas { display: block; } </style>
</head>
<body>
    <script>
let hue_offset = 0;
let particles = [];
let rot_speed;

function setup() {
  createCanvas(800, 600);
  colorMode(HSB, 360, 100, 100, 100);
  angleMode(DEGREES);
  strokeCap(ROUND);
  strokeJoin(ROUND);
}

function draw() {
  background(0, 0, 0, 10);
  translate(width / 2, height / 2);

  hue_offset = (hue_offset + 0.7) % 360;
  rot_speed = map(mouseX, 0, width, 0.2, 4, true);
  let complexity = map(mouseY, 0, height, 2, 12, true);

  // Layer 3: Background aura (very slow, thick, and blurry)
  drawMandala(8, frameCount * 0.05, 450, 40, complexity * 0.5, 1);

  // Layer 2: Main structure
  drawMandala(floor(complexity), frameCount * rot_speed * 0.5, 280, 5, complexity, 2);

  // Layer 1: Foreground details (faster, thinner)
  drawMandala(floor(complexity) * 2, -frameCount * rot_speed, 180, 2, complexity, 3);

  // Central pulsating core
  drawCore();

  // Particle systems
  updateAndDisplayParticles();
}

function drawMandala(sides, rotation, radius, weight, complexity, mode) {
  push();
  rotate(rotation);
  for (let i = 0; i < sides; i++) {
    let angle = (360 / sides) * i;
    let current_hue = (hue_offset + angle * mode * 2) % 360;

    // Use Perlin noise for organic, pulsing radius
    let r_noise = noise(i * 10, frameCount * 0.005 * mode);
    let dynamic_radius = radius + map(r_noise, 0, 1, -radius * 0.4, radius * 0.4);

    // Calculate start and end points of the main arm
    let x1 = cos(angle) * dynamic_radius * 0.2;
    let y1 = sin(angle) * dynamic_radius * 0.2;
    let x2 = cos(angle) * dynamic_radius;
    let y2 = sin(angle) * dynamic_radius;

    // Draw main arm with a gradient
    for (let j = 0; j < 1; j += 0.05) {
      let inter_x = lerp(x1, x2, j);
      let inter_y = lerp(y1, y2, j);
      let h = (current_hue + j * 40) % 360;
      stroke(h, 80, 100, 20);
      strokeWeight(weight * (1 - j));
      point(inter_x, inter_y);
    }


    // Draw complex, swirling patterns at the end of each arm
    push();
    translate(x2, y2);
    rotate(-rotation * 2 + frameCount * mode * 2);
    strokeWeight(weight * 0.4);
    noFill();
    for (let j = 0; j < complexity; j++) {
      let p_angle = map(j, 0, complexity, 0, 360);
      let p_hue = (current_hue + j * 15) % 360;
      stroke(p_hue, 70, 100, 60);
      let p_size = dynamic_radius * 0.3 * (1 - j / complexity) * (sin(frameCount * 2 + i * 20) * 0.5 + 0.5);
      ellipse(0, 0, p_size, p_size);
      rotate(360 / complexity);
    }
    pop();
  }
  pop();
}

function drawCore() {
  let core_size = 100 + sin(frameCount * 1.5) * 40;
  for (let i = 15; i > 0; i--) {
    let ratio = i / 15.0;
    let h = (hue_offset + 180 + i * 10) % 360;
    let s = 90 - ratio * 50;
    let b = 100;
    let a = 15 * ratio * ratio;
    fill(h, s, b, a);
    noStroke();
    ellipse(0, 0, core_size * ratio, core_size * ratio);
  }
}

function updateAndDisplayParticles() {
  // Add new spiraling particles continuously
  if (frameCount % 2 === 0) {
    particles.push(new Particle(true));
  }

  // Mouse interaction burst
  if (mouseIsPressed) {
    for (let i = 0; i < 5; i++) {
      particles.push(new Particle(false));
    }
  }

  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    particles[i].display();
    if (particles[i].isDead()) {
      particles.splice(i, 1);
    }
  }
}

class Particle {
  constructor(isSpiral) {
    this.isSpiral = isSpiral;
    if (this.isSpiral) {
      // Create a particle that spirals out from the center
      this.pos = p5.Vector.random2D().mult(random(20));
      this.vel = this.pos.copy().setMag(random(0.5, 2));
    } else {
      // Create a particle that bursts from the center towards the mouse
      this.pos = createVector(0, 0);
      let mouseVec = createVector(mouseX - width / 2, mouseY - height / 2);
      if (mouseVec.mag() < 1) { // Avoid zero vector
        mouseVec = p5.Vector.random2D();
      }
      this.vel = mouseVec.setMag(random(4, 8));
      this.vel.rotate(random(-20, 20));
    }
    this.acc = createVector(0, 0);
    this.lifespan = 100;
    this.size = random(2, 6);
    this.hue = (hue_offset + random(-40, 40)) % 360;
  }

  applyForce(force) {
    this.acc.add(force);
  }

  update() {
    if (this.isSpiral) {
      let angle = atan2(this.pos.y, this.pos.x);
      let rotationalForce = createVector(-sin(angle), cos(angle));
      rotationalForce.mult(0.1 * rot_speed * 0.5);
      this.applyForce(rotationalForce);
    }

    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.mult(0); // Reset acceleration each frame

    this.lifespan -= 1.5;
    this.size *= 0.98; // Shrink over time
  }

  display() {
    noStroke();
    fill(this.hue, 90, 100, this.lifespan);
    ellipse(this.pos.x, this.pos.y, this.size);
  }

  isDead() {
    return this.lifespan < 0 || this.pos.mag() > width / 1.5;
  }
}
    </script>
</body>
</html>
