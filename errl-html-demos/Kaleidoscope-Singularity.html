<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus: Kaleidoscopic Singularity</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .nexus-ui {
            position: absolute;
            bottom: 30px;
            right: 30px;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            text-align: right;
            z-index: 10;
        }
        .status-glow {
            color: #0ff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>

    <div class="nexus-ui text-xs tracking-widest uppercase">
        <div class="status-glow mb-1">Refraction Active: 12-Fold</div>
        <div class="text-magenta-500">Symmetry Mode: Recursive</div>
        <div class="text-white opacity-40">System Time: <span id="clock">00:00:00</span></div>
    </div>

<script>
    let scene, camera, renderer, postScene, postCamera, renderTarget, postMaterial;
    let particles = [];
    let time = 0;
    const PARTICLE_COUNT = 300;

    function init() {
        // --- Core 3D Scene ---
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 400;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Render target for post-processing
        renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);

        // --- Particle System (The Soul) ---
        const geometry = new THREE.BufferGeometry();
        const posArr = new Float32Array(PARTICLE_COUNT * 3);
        const colArr = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particles.push({
                pos: new THREE.Vector3(
                    (Math.random() - 0.5) * 600,
                    (Math.random() - 0.5) * 600,
                    (Math.random() - 0.5) * 600
                ),
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                )
            });
            posArr[i * 3] = particles[i].pos.x;
            posArr[i * 3 + 1] = particles[i].pos.y;
            posArr[i * 3 + 2] = particles[i].pos.z;
            
            colArr[i * 3] = Math.random();
            colArr[i * 3 + 1] = Math.random();
            colArr[i * 3 + 2] = 1.0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colArr, 3));

        const material = new THREE.PointsMaterial({
            size: 5,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);
        this.points = points;

        // --- Post-Processing (The Lens) ---
        postScene = new THREE.Scene();
        postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        
        const shaderCode = {
            vertex: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragment: `
                uniform sampler2D tDiffuse;
                uniform float time;
                varying vec2 vUv;

                void main() {
                    vec2 uv = vUv - 0.5;
                    float angle = atan(uv.y, uv.x);
                    float radius = length(uv);

                    // 12-Fold Symmetry Refraction
                    float segments = 12.0;
                    angle = mod(angle, 2.0 * 3.14159 / segments);
                    angle = abs(angle - 3.14159 / segments);

                    vec2 newUv = vec2(cos(angle), sin(angle)) * radius;
                    newUv += 0.5;

                    // Chromatic Aberration
                    float r = texture2D(tDiffuse, newUv + vec2(0.005 * sin(time), 0.0)).r;
                    float g = texture2D(tDiffuse, newUv).g;
                    float b = texture2D(tDiffuse, newUv - vec2(0.005 * sin(time), 0.0)).b;

                    gl_FragColor = vec4(r, g, b, 1.0);
                    
                    // Add a radial vignette / glow
                    gl_FragColor *= (1.2 - radius);
                }
            `
        };

        postMaterial = new THREE.ShaderMaterial({
            uniforms: {
                tDiffuse: { value: renderTarget.texture },
                time: { value: 0.0 }
            },
            vertexShader: shaderCode.vertex,
            fragmentShader: shaderCode.fragment
        });

        const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), postMaterial);
        postScene.add(quad);

        window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderTarget.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        // Update Particles
        const positions = points.geometry.attributes.position.array;
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const p = particles[i];
            p.pos.add(p.velocity);

            // Boundary Check (Recursive Wrap)
            if (Math.abs(p.pos.x) > 400) p.velocity.x *= -1;
            if (Math.abs(p.pos.y) > 400) p.velocity.y *= -1;
            if (Math.abs(p.pos.z) > 400) p.velocity.z *= -1;

            positions[i * 3] = p.pos.x;
            positions[i * 3 + 1] = p.pos.y;
            positions[i * 3 + 2] = p.pos.z;
        }
        points.geometry.attributes.position.needsUpdate = true;
        scene.rotation.y += 0.005;

        // Render to texture
        renderer.setRenderTarget(renderTarget);
        renderer.render(scene, camera);

        // Render post-process to screen
        renderer.setRenderTarget(null);
        postMaterial.uniforms.time.value = time;
        renderer.render(postScene, postCamera);

        // Update UI
        document.getElementById('clock').innerText = new Date().toLocaleTimeString();
    }

    window.onload = () => {
        init();
        animate();
    };
</script>
</body>
</html>

