<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus: Neural Lattice Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #0ff; font-family: 'monospace'; }
        canvas { display: block; }
        .nexus-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-size: 0.7rem;
            text-shadow: 0 0 10px #0ff;
        }
        #heart-rate { color: #f0f; }
    </style>
</head>
<body>

    <div class="nexus-ui">
        <div>Neural Lattice Status: <span class="text-white">SYNCHRONIZED</span></div>
        <div>Symmetry Factor: <span class="text-white">OCTAHEDRAL</span></div>
        <div>Heartbeat: <span id="heart-rate">72 BPM</span></div>
    </div>

<script>
    let scene, camera, renderer, points, lines;
    const PARTICLE_COUNT = 500;
    const particles = [];
    let beat = 0;
    let mouseX = 0, mouseY = 0;

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 500;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Create Neural Nodes
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const x = (Math.random() - 0.5) * 800;
            const y = (Math.random() - 0.5) * 800;
            const z = (Math.random() - 0.5) * 800;

            particles.push({
                x, y, z,
                originalX: x, originalY: y, originalZ: z,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                vz: (Math.random() - 0.5) * 2
            });

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            colors[i * 3] = Math.random();
            colors[i * 3 + 1] = Math.random();
            colors[i * 3 + 2] = 1.0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 4,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        points = new THREE.Points(geometry, material);
        scene.add(points);

        // Create Connection Tracers (Lines)
        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.2,
            blending: THREE.AdditiveBlending
        });

        const lineGeometry = new THREE.BufferGeometry();
        lines = new THREE.LineSegments(lineGeometry, lineMaterial);
        scene.add(lines);

        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('mousemove', onMouseMove, false);
    }

    function onMouseMove(event) {
        mouseX = (event.clientX - window.innerWidth / 2) * 0.5;
        mouseY = (event.clientY - window.innerHeight / 2) * 0.5;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        beat += 0.05;
        const pulse = Math.sin(beat) * 0.5 + 0.5;
        const bpm = Math.round(60 + pulse * 40);
        document.getElementById('heart-rate').innerText = `${bpm} BPM`;

        const posAttr = points.geometry.attributes.position;
        const linePositions = [];

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const p = particles[i];
            
            // Apply Pulse Logic (Expansion/Contraction)
            const factor = 1 + pulse * 0.1;
            p.x = p.originalX * factor + Math.sin(beat + p.originalY) * 10;
            p.y = p.originalY * factor + Math.cos(beat + p.originalX) * 10;
            p.z = p.originalZ * factor;

            // React to Camera/Mouse Position
            p.x += (mouseX - p.x) * 0.01;
            p.y += (-mouseY - p.y) * 0.01;

            posAttr.array[i * 3] = p.x;
            posAttr.array[i * 3 + 1] = p.y;
            posAttr.array[i * 3 + 2] = p.z;

            // Connect nearby points with tracers
            for (let j = i + 1; j < i + 5; j++) {
                if (j < PARTICLE_COUNT) {
                    const p2 = particles[j];
                    const dist = Math.sqrt((p.x - p2.x)**2 + (p.y - p2.y)**2 + (p.z - p2.z)**2);
                    if (dist < 150) {
                        linePositions.push(p.x, p.y, p.z, p2.x, p2.y, p2.z);
                    }
                }
            }
        }

        posAttr.needsUpdate = true;

        // Update Tracer Lattice
        lines.geometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
        
        // RGB Chromatic Drift
        points.material.color.setHSL((beat * 0.1) % 1, 1, 0.7);
        lines.material.color.setHSL((beat * 0.1 + 0.5) % 1, 1, 0.5);

        // Slow Rotation
        scene.rotation.y += 0.002;
        scene.rotation.x += 0.001;

        renderer.render(scene, camera);
    }

    window.onload = function() {
        init();
        animate();
    };
</script>
</body>
</html>
